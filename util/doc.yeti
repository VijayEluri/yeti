load yeti.lang.compiler.showtype;

doc_dir = _argv.[0];

(@) = strReplace '<' '&lt;' . strReplace '>' '&gt;' . strReplace '&' '&amp;';

format_doc _ doc =
    if doc =~ '\S' then
        esc = strReplace "\n" "<br>" . substAll "\n[ \\t]*\n" "<p>";
        "<div class=\"doc\">\(esc (doc@))</div>"
    else
        undef_str
    fi;

html_page name doc descr typedefs =
"""<html><style type="text/css">
.main { background: white; line-height: 130% }
.type { background: white }
.other { background: #cccccc }
.struct { //background: #bbffbb;
          background: #ffffff;
          border-width: 1px;
          border-color: black; border-style: solid;
          padding-left: 0.1em;
          padding-right: 0.1em;
          margin-left: 1pt;
          margin-right: 1pt;
          padding-top: 1px;
          padding-bottom: 1pt;
          margin-top: 1px;
          margin-bottom: -3pt;
/*          padding: 3pt;
          margin-left: 3pt;
          margin-right: 3pt;
          margin-top: 2pt;
          margin-bottom: -3pt;*/
          display: inline-table }
.variant { background: #c7c7ff; border-width: 1px;
          border-color: black; border-style: solid;
          padding-left: 0.1em;
          padding-right: 0.1em;
          margin-left: 1pt;
          margin-right: 1pt;
          padding-top: 1px;
          padding-bottom: 1pt;
          margin-top: 1px;
          margin-bottom: -3pt;
          display: inline-table }
.doc { background: white }
</style><title>\(name@)</title>
<body>
<p class="main">
<h2>Module \(name@);</h2>
\(format_doc () doc)
<hr>
\(typedefs)
<div class="type">
\(descr)
</div>
</body>
</html>""";

structMember f = """
<table border=0><tr><td valign=top nowrap>
\(if f.mutable then '<strong>var</strong> ' else '' fi)
\(f.tag)\(f.name) <strong>is</strong>
</td><td>\(f.typeStr)
\(if f.last then '' else ',' fi)</td></tr></table>
\(if f.description != "" then
        format_doc '' f.description else '' fi)
""";

formatStruct = {
    wrap s = "{\(s)}",
    member = structMember
};

formatVariant = {
    wrap s = " \(s) ",
    member m = "\(m.name) \(m.typeStr)\(if m.last then '' else ' | ' fi)"
};

type_as_html st =
   (var cur = '';
    var big = false;
    var depth = 0;
    format indent t =
       (old = cur;
        depth := depth + 1;

        dataType l what param =
           (types = [:];
            var flag = false;
            for l do {name, type}:
                big := false;
                types.[name] := format indent type;
                flag := flag or big
            done;
            big := flag or length l >= 3 or
                not empty? (find ((!= '') . (.description)) l);
            cur := what;
            iter l =
                case l of
                f :: r: param.member (f is typeitem<type> with {
                                        last = empty? r,
                                        typeStr = types.[f.name]
                                      }) :: iter r;
                _: []
                esac;
            ls = iter l;
            if big then
                a = map (_ s = "<div class=field>\(s)</div>") ls;
                block =
                    if depth == 1 then ' style="display: block; margin: 2pt"'
                                  else '' fi;
                param.wrap "<div class=\"\(what)\"\(block)>\
                           "\(strJoin '' a)</div>"
            else
                param.wrap " \(strJoin '' ls) "
            fi);

        s = case t of
            Struct  l: dataType l 'struct' formatStruct;
            Variant l: dataType l 'variant' formatVariant;

            Parametric {type, params}:
                res = strJoin ', ' (map (format indent) params);
                res = "\(type)&lt;\(res)&gt;";
                if cur != '' then
                    cur := '';
                    "<span class=\"other\">\(res)</span>"
                else
                    res
                fi;
            _:
                if cur != '' then
                    cur := '';
                    "<span class=\"other\">\(st indent t)</span>"
                else
                    st indent t
                fi
            esac;
        depth := depth - 1;
        cur := old;
        s);
    format);

typedef_param param =
    if empty? param then "" else "<\(strJoin ', ' param)>" fi;

typedef_html to_html {name, type, param} =
"""<div class="typedef">
<b>typedef</b> \(name@)\(typedef_param param@) = <span class="type">
\(to_html '' type)</span></div><p>""";

do {type, name, doc, typedefs}:
    if defined? doc_dir then
        var stf _ _ = '';
        to_html = type_as_html (_ i = stf i);
        stf := showType [/*Indent '&nbsp; &nbsp;',*/ CommentDoc (),
                         ShowType to_html, FormatDoc format_doc];
        descr = to_html '' type;
        //descr = strReplace "\n" "<br>\n" descr;
        page = html_page name doc descr
                    (strJoin '' (map (typedef_html to_html) typedefs));
        writeFile "\(doc_dir)/\(name).html" 'utf-8' do f:
            f.writeln page
        done
    else
        if doc != "" then
            println "/*\n\(doc)\n*/"
        fi;
        println "module \(name);\n";
        for typedefs do {name, type, param}:
            println "typedef \(name)\(typedef_param param) = \
                    "\(showType [CommentDoc ()] '' type)\n"
        done;
        println (showType [CommentDoc ()] '' type);
    fi
done
