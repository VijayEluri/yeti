load yeti.lang.compiler.showtype;

doc_dir = _argv.[0];

formatType template =
   (var cur = '';
    var big = false;
    var depth = 0;
    var st _ _ = '';
    leftArrow = template.escape '<';
    rightArrow = template.escape '>';

    format indent t =
       (old = cur;
        depth := depth + 1;

        dataType l what =
           (types = [:];
            var flag = false;
            for l do {name, type}:
                big := false;
                types.[name] := format indent type;
                flag := flag or big
            done;
            big := flag or length l >= 3 or
                not empty? (find ((!= '') . (.description)) l);
            cur := what;
            fieldDesc f =
                f is typeitem<type> with { typeStr = types.[f.name] };
            { big, fields = array (map fieldDesc l), top = depth == 1 });

        s = case t of
            Struct  l: template.struct (dataType l 'struct');
            Variant l: template.variant (dataType l 'variant');

            Parametric {type, params}:
                res = strJoin ', ' (map (format indent) params);
                res = type ^ leftArrow ^ res ^ rightArrow;
                if cur != '' then
                    cur := '';
                    template.other res
                else
                    res
                fi;
            _:
                if cur != '' then
                    cur := '';
                    template.other (st indent t)
                else
                    st indent t
                fi
            esac;
        depth := depth - 1;
        cur := old;
        s);

    st := showType (ShowType format :: template.options);
    format);

(@) = strReplace '<' '&lt;' . strReplace '>' '&gt;' . strReplace '&' '&amp;';

formatDoc _ doc =
    if doc =~ '\S' then
        esc = strReplace "\n" "<br>" . substAll "\n[ \\t]*\n" "<p>";
        "<div class=\"doc\">\(esc (doc@))</div>"
    fi;

html_page {name, doc, descr, typedefs} =
"""<html><style type="text/css">
.main { background: white; line-height: 130% }
.type { background: white }
.other { background: #cccccc }
.field { padding: 1.5pt }
.struct { //background: #bbffbb;
          background: #ffffff;
          border-width: 1px;
          border-color: black; border-style: solid;
          padding-left: 0.1em;
          padding-right: 0.1em;
          margin-left: 1pt;
          margin-right: 1pt;
          padding-top: 1px;
          padding-bottom: 1pt;
          margin-top: 1px;
          margin-bottom: 0pt;
          display: inline-block }
.variant { background: #c7c7ff; border-width: 1px;
          border-color: black; border-style: solid;
          padding-left: 0.1em;
          padding-right: 0.1em;
          margin-left: 1pt;
          margin-right: 1pt;
          padding-top: 1px;
          padding-bottom: 1pt;
          margin-top: 1px;
          margin-bottom: 0pt;
          display: inline-block }
.doc { background: white }
</style><title>\(name@)</title>
<body>
<p class="main">
<h2>Module \(name@);</h2>
\(formatDoc () doc)
<hr>
\(typedefs)
<div class="type">
\(descr)
</div>
</body>
</html>""";

complexType what before sep after f {big, top, fields} =
   (last = pop fields;
    var fields = map (f sep) fields ++ [f '' last];
    if big then
        block = if top then ' style="display: block; margin: 2pt"' fi;
        fields := "<div class=\"\(what)\"\(block)>" :: 
            map (_ s = "<div class=field>\(s)</div>") fields ++ ["</div>"]
    fi;
    strJoin '' (before :: fields ++ [after]));

to_html = formatType {
    struct = complexType 'struct' '{' ',' '}' do sep f:
        strJoin '' [
            if f.mutable then '<strong>var</strong> ' fi,
            f.tag, f.name, ' <strong>is</strong> ',
            f.typeStr, sep,
            if f.description != '' then formatDoc '' f.description fi
        ]
    done,
    variant = complexType 'variant' ' ' ' | ' ' ' do sep m:
        "\(m.name) \(m.typeStr)\(sep)"
    done,
    other descr = "<span class=\"other\">\(descr)</span>",
    escape = (@),
    options = [FormatDoc formatDoc]
};

typedef_param param =
    if not empty? param then "<\(strJoin ', ' param)>" fi;

typedef_html {name, type, param} =
"""<div class="typedef">
<b>typedef</b> \(name@)\(typedef_param param@) = <span class="type">
\(to_html '' type)</span></div><p>""";

do {type, name, doc, typedefs}:
    descr = to_html '' type;
    page = html_page {
        name, doc, descr,
        typedefs = strJoin '' (map typedef_html typedefs)
    };
    writeFile "\(doc_dir)/\(name).html" 'utf-8' (`putLines` [page])
done
