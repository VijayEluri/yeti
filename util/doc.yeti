load yeti.lang.compiler.showtype;

doc_dir = _argv.[0];

/* TODO
 * links to typedefs, typedefs in different modules and java class javadocs
 * some formatting for the doc strings
 * maybe A | B | C should be A\n| B\n| C, instead of | in the eol
 * ... general style improvements, make it look nicer?
 */

formatType template =
   (var cur = '';
    var big = false;
    var depth = 0;
    var st _ _ = '';
    leftArrow = template.escape '<';
    rightArrow = template.escape '>';

    format indent t =
       (old = cur;
        depth := depth + 1;

        enclose s t =
            case t of
            Function _: "(\(s))";
            Variant (_ :: _): "(\(s))";
            _: s;
            esac;

        dataType l variant =
           (types = [:];
            var flag = false;
            for l do {name, type}:
                big := false;
                var str = format indent type;
                if variant then
                    str := enclose str type
                fi;
                types.[name] := str;
                flag := flag or big
            done;
            docs = not empty? (find ((!= '') . (.description)) l);
            big := docs or flag or length l >= 3;
            cur := if variant then 'variant' else 'struct' fi;
            fieldDesc f =
                f is typeitem<type> with { typeStr = types.[f.name] };
            { big, docs, fields = array (map fieldDesc l), top = depth == 1 });

        other s =
            if cur != '' then
                cur := '';
                template.other s
            else
                s
            fi;

        s = case t of
            Struct  l: template.struct (dataType l false);
            Variant l: template.variant (dataType l true);

            Function l:
                var flag = false;
                fields = array [];
                for l do type:
                    big := false;
                    push fields (enclose (format indent type) type);
                    flag := flag or big
                done;
                big := flag or length fields > 4;
                template.function {big, docs = false, fields, top = depth == 1};
     
            Parametric {type, params}:
                res = strJoin ', ' (map (format indent) params);
                other (type ^ leftArrow ^ res ^ rightArrow);

            Alias {type, alias}:
                other "(\(template.alias alias (format indent type)))";

            _:
                other (st indent t);
            esac;
        depth := depth - 1;
        cur := old;
        s);

    st := showType (ShowType format :: template.options);
    format);

(@) = strReplace '<' '&lt;' . strReplace '>' '&gt;' . strReplace '&' '&amp;';

parseDoc' doc =
   (doc = map strTrim (strSplit "\n" (substAll "(?:^|\n[ \\t]+)\\*" "\n" doc@));
    var descr = [];
    args = array [];
    exceptions = array [];
    var prev = '';
    var state = \();
    join = map (strJoin "\n") . filter ((not) . ('' ==) . head)
                              . groupBy (on (==) ('' ==));
    defState to line =
        if prev == '' and line == 'Exceptions:' then
            state := defState exceptions
        else
            case like '^(\w++)\s++-\s++(.*)$' line () of
            [_, arg, text]:
                push to {arg, text = array [text]};
            _:
                if empty? to then
                    push to {arg = "???", text = array [line]}
                else
                    push to.[length to - 1].text line
                fi
            esac
        fi;
    state := do line:
        if prev == '' and line == 'Arguments:' then
            state := defState args
        else
            descr := line :: descr
        fi
    done;
    for doc do line:
        state (strTrim line);
        prev := line
    done;
    format = strJoin '<p></p>';
    descr = reverse (join descr);
    descr = if not empty? descr or not empty? args then
        arg {arg, text} = "<tr><td><var>\(arg)</var><td>-<td>\(format text)";
        "<div class=\"doc\">\(format descr)\
        "\(if not empty? args then
            "<table class=\"args\">\(strJoin '' (map arg args))</table>"
           fi)</div>"
    fi;
    {descr, args = map (.arg) args});

parseDoc doc =
    if doc != '' then parseDoc' doc else {descr = undef_str, args = []}  fi;

formatDoc _ doc =
    (parseDoc doc).descr;

html_page {name, doc, descr, typedefs} =
"""<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\"
\"http://www.w3.org/TR/html4/strict.dtd\">
<html><meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
<style type="text/css">
.main { background: white; line-height: 130%; font-family: sans-serif }
.type { background: white; font-size: 12pt; }
.sn { font-size: 13pt; font-family: monospace }
.vn { font-size: 13pt }
.other { background: #cccccc; display: inline; }
.field { padding: 1.5pt }
.wdoc { padding-top: 0.5em; padding-bottom: 0.4em; }
var { font: italic 11pt sans-serif }
.args { padding-left: 1.4em }
/*.wdoc { margin-top: 0.6em; margin-bottom: 0.6em; } */
.box {
    border-width: 1px;
    border-color: black;
    border-style: solid;
    padding-left: 0.1em;
    padding-right: 0.1em;
    margin-left: 1pt;
    margin-right: 1pt;
    padding-top: 1px;
    padding-bottom: 1pt;
    margin-top: 1px;
    margin-bottom: 0pt;
    display: inline-block;
}
.module { color: #000080 }
em { color: #000080; font: bold 13pt sans-serif }
.function { background: #ffffff }
.struct { background: #ffffff }
.variant { background: #c7c7ff }
/* background: #bbffbb; */
.ft { padding-left: 0em }
.doc { background: #ffffa8;
       padding-left: 2em;
       padding-top: 0.5em;
       padding-bottom: 0.5em;
       padding-right: 0.5em;
       font-size: 12pt;
       }
</style><title>\(name@)</title>
<body>
<div class="main">
<h2><span class=module>module</span> \(name@)</h2>
\(formatDoc () doc)
<p>
\(typedefs)
<h3>Module signature</h3>
<div class="type">
\(descr)
</div>
</div>
</body>
</html>""";

complexType what before sep after f {big, docs, top, fields} =
   (style = if docs then '"field wdoc"' else 'field' fi;
    str sep field =
       (descr = f sep field;
        var s = strJoin '' (tail descr);
        if big then
            "<div class=\(style)>\(s)\(head descr)</div>\n"
        else
            s
        fi);
    last = pop fields;
    var fields = map (str sep) fields ++ [str '' last];
    if big then
        block = if top then ' style="display: block; margin: 2pt"' fi;
        fields := "<div class=\"box \(what)\"\(block)>" :: fields ++ ["</div>"]
    fi;
    strJoin '' (before :: fields ++ [after]));

to_html = formatType {
    struct = complexType 'struct' '<em>{</em>' ', ' '<em>}</em>' do sep f:
        {descr, args} = parseDoc f.description;
        args = map (_ arg = " <var>\(arg)</var>") args;
        concat [[descr, if f.mutable then '<em>var </em>' fi,
                 '<span class=sn>', f.tag, f.name@, '</span>'],
                args, ['<em> is </em>', f.typeStr, sep]]
    done,
    variant = complexType 'variant' '' ' | ' '' do sep m:
        {descr} = parseDoc m.description;
        [descr, '<span class=vn>', m.name, '</span> ', m.typeStr, sep]
    done,
    function = complexType 'function' '' ' &rarr; ' ''
                           (_ sep t = ['', t, sep]),
    alias alias type = "\(alias)<em> is </em>\(type)",
    other descr = "<div class=\"other\">\(descr)</div>",
    escape s =
        case s of
        '<': '<tt>&lt;</tt>';
        '>': '<tt>&gt;</tt>';
        _: s@
        esac,
    options = [FormatDoc formatDoc]
};

typedef_param param =
    if not empty? param then "<\(strJoin ', ' param)>" fi;

typedef_html {name, type, param} =
    "<div class=\"type\"><em>typedef</em> \
    "\(name@)\(typedef_param param@) = \(to_html '' type)</div>";

do {type, name, doc, typedefs}:
    descr = to_html '' type;
    page = html_page {
        name, doc, descr,
        typedefs = strJoin '<p>' (map typedef_html typedefs)
    };
    writeFile "\(doc_dir)/\(name).html" 'utf-8' (`putLines` [page])
done
