<?xml version="1.0"?>
<!DOCTYPE MODE SYSTEM "xmode.dtd">
<MODE>
	<!-- XXX Broken, because jedit don't allow SPAN END to be regex nor
	     keyword, and don't allow SEQ_REGEXP to match multiple lines.
	     That way it's impossible to correctly color yeti type definitions,
	     not even speaking of error detection like the vim syntax file does.
	 -->
	<PROPS>
		<PROPERTY NAME="indentOpenBrackets" VALUE="{"/>
		<PROPERTY NAME="indentCloseBrackets" VALUE="}"/>
		<PROPERTY NAME="unalignedOpenBrackets" VALUE="(" />
		<PROPERTY NAME="unalignedCloseBrackets" VALUE=")" />
		<PROPERTY NAME="lineUpClosingBracket" VALUE="TRUE"/>
		<PROPERTY NAME="multipleBracketIndent" VALUE="TRUE" />
		<PROPERTY NAME="commentStart" VALUE="/*"/>
		<PROPERTY NAME="commentEnd" VALUE="*/"/>
		<PROPERTY NAME="lineComment" VALUE="//"/>
		<PROPERTY NAME="noWordSep" VALUE="_?'"/>
		<!--
		<PROPERTY NAME="indentNextLines" VALUE="\s*(if|case|try|class)\s.*"/>
		<PROPERTY NAME="unindentThisLine" VALUE="^\s*(else\s*|elif\s.*|catch\s.*|finally\s*)$"/>
		<PROPERTY NAME="unindentNextLines" VALUE="^\s*(fi|esac|done|end)[;\s]*$"/>
		-->
	</PROPS>

	<RULES IGNORE_CASE="FALSE" HIGHLIGHT_DIGITS="TRUE" NO_WORD_SEP="#$?'"
	       DIGIT_RE="[+-]?\d+(?:\.\d+)(?:eE(?:[+-]?\d+)?)?|0x[0-9A-Fa-f]+">
		<SPAN TYPE="COMMENT1">
			<BEGIN>/*</BEGIN>
			<END>*/</END>
		</SPAN>

		<EOL_SPAN TYPE="COMMENT2">//</EOL_SPAN>

		<SEQ_REGEXP TYPE="MARKUP" AT_WORD_START="TRUE"
			HASH_CHARS="iatu-">(?:(?:is\b|as\b|unsafely_as\b|typedef\s[^=]+=|-&gt;|\|)(\s|\n|//[^\n]*|/\*([^*]|\*[^/])*\*/)*(?:[A-Z][\w']*\s+)*(?:[a-z'~][\w'.$?]*|\(\))|&lt;[^&gt;]*&gt;\s*)+</SEQ_REGEXP>

		<SEQ_REGEXP TYPE="LABEL" HASH_CHARS="ABCDEFGHIJKLMNOPQRSTUVWXYZ" AT_WORD_START="TRUE">[A-Z]\w*(?=[^\w#$?']|$)</SEQ_REGEXP>

		<SPAN TYPE="LITERAL1" DELEGATE="DOUBLE_QUOTE">
			<BEGIN>"""</BEGIN>
			<END>"""</END>
		</SPAN>

		<SEQ_REGEXP TYPE="MARKUP" AT_WORD_START="TRUE"
			HASH_CHAR="new">new(\s+[\w.]+)\b</SEQ_REGEXP>
		<SEQ_REGEXP TYPE="MARKUP" AT_WORD_START="TRUE"
			HASH_CHAR="instanceof">instanceof(\s+[\w.]+)\b</SEQ_REGEXP>
		<SEQ_REGEXP TYPE="MARKUP" AT_WORD_START="TRUE"
			HASH_CHAR="classOf">classOf(\s+[\w.]+)\b</SEQ_REGEXP>

		<SPAN TYPE="LITERAL1" DELEGATE="DOUBLE_QUOTE" NO_LINE_BREAK="TRUE">
			<BEGIN>"</BEGIN>
			<END>"</END>
		</SPAN>

		<SPAN TYPE="LITERAL1" AT_WORD_START="TRUE">
			<BEGIN>'</BEGIN>
			<END>'</END>
		</SPAN>

		<SPAN DELEGATE="MAIN"><BEGIN>(</BEGIN><END>)</END></SPAN>
		<SPAN MATCH_TYPE="OPERATOR" DELEGATE="MAIN">
			<BEGIN>[</BEGIN>
			<END>]</END>
		</SPAN>
		<SPAN MATCH_TYPE="OPERATOR" DELEGATE="MAIN">
			<BEGIN>{</BEGIN>
			<END>}</END>
		</SPAN>
		<SPAN_REGEXP MATCH_TYPE="KEYWORD2" TYPE="MARKUP"
		             AT_WORD_START="TRUE" HASH_CHAR="import">
			<BEGIN>import\b</BEGIN>
			<END>;</END>
		</SPAN_REGEXP>
		<SPAN_REGEXP MATCH_TYPE="KEYWORD2" TYPE="MARKUP"
		             AT_WORD_START="TRUE" HASH_CHAR="program">
			<BEGIN>program\b</BEGIN>
			<END>;</END>
		</SPAN_REGEXP>
		<SPAN_REGEXP MATCH_TYPE="KEYWORD2" TYPE="MARKUP"
		             AT_WORD_START="TRUE" HASH_CHAR="module">
			<BEGIN>module\b</BEGIN>
			<END>;</END>
		</SPAN_REGEXP>
		<SPAN_REGEXP MATCH_TYPE="KEYWORD1" TYPE="MARKUP"
		             AT_WORD_START="TRUE" HASH_CHAR="catch">
			<BEGIN>catch\b</BEGIN>
			<END>:</END>
		</SPAN_REGEXP>

		<SEQ TYPE="OPERATOR">!</SEQ>
		<SEQ TYPE="OPERATOR">%</SEQ>
		<!-- SEQ TYPE="OPERATOR">&gt;</SEQ -->
		<SEQ TYPE="OPERATOR">&lt;</SEQ>
		<SEQ TYPE="OPERATOR">*</SEQ>
		<SEQ TYPE="OPERATOR">+</SEQ>
		<SEQ TYPE="OPERATOR">,</SEQ>
		<!-- SEQ TYPE="OPERATOR">-</SEQ -->
		<SEQ TYPE="OPERATOR">/</SEQ>
		<SEQ TYPE="OPERATOR">:</SEQ>
		<SEQ TYPE="OPERATOR">;</SEQ>
		<SEQ TYPE="OPERATOR">=</SEQ>
		<SEQ TYPE="OPERATOR">@</SEQ>
		<SEQ TYPE="OPERATOR">\</SEQ>
		<SEQ TYPE="OPERATOR">^</SEQ>
		<SEQ TYPE="OPERATOR">~</SEQ>
		<SEQ TYPE="INVALID">)</SEQ>
		<SEQ TYPE="INVALID">]</SEQ>
		<SEQ TYPE="INVALID">}</SEQ>

		<KEYWORDS>
			<KEYWORD1>do</KEYWORD1>
			<KEYWORD1>done</KEYWORD1>
			<KEYWORD1>if</KEYWORD1>
			<KEYWORD1>elif</KEYWORD1>
			<KEYWORD1>else</KEYWORD1>
			<KEYWORD1>case</KEYWORD1>
			<KEYWORD1>esac</KEYWORD1>
			<KEYWORD1>fi</KEYWORD1>>
			<KEYWORD1>finally</KEYWORD1>
			<KEYWORD1>throw</KEYWORD1>
			<KEYWORD1>_</KEYWORD1>
			<KEYWORD2>load</KEYWORD2>
			<KEYWORD1>of</KEYWORD1>
			<KEYWORD1>then</KEYWORD1>
			<KEYWORD1>try</KEYWORD1>
			<KEYWORD1>yrt</KEYWORD1>
			<KEYWORD1>for</KEYWORD1>
			<KEYWORD1>synchronized</KEYWORD1>
			<KEYWORD1>loop</KEYWORD1>
			<KEYWORD1>class</KEYWORD1>
			<KEYWORD1>end</KEYWORD1>

			<!-- TYPES -->
			<KEYWORD3>get</KEYWORD3>
			<KEYWORD3>norec</KEYWORD3>
			<KEYWORD3>set</KEYWORD3>
			<KEYWORD3>var</KEYWORD3>
			<KEYWORD3>void</KEYWORD3>

			<!-- CONSTANTS -->
			<LITERAL2>false</LITERAL2>
			<LITERAL2>true</LITERAL2>
			<LITERAL2>undef_bool</LITERAL2>
			<LITERAL2>undef_str</LITERAL2>

			<OPERATOR>and</OPERATOR>
			<OPERATOR>or</OPERATOR>
			<OPERATOR>in</OPERATOR>
			<OPERATOR>not</OPERATOR>
		</KEYWORDS>
	</RULES>

	<RULES DEFAULT="LITERAL1" SET="DOUBLE_QUOTE">
		<SPAN DELEGATE="MAIN" TYPE="OPERATOR">
			<BEGIN>\(</BEGIN>
			<END>)</END>
		</SPAN>
		<SEQ TYPE="LITERAL4">\"</SEQ>
		<SEQ TYPE="LITERAL4">\\</SEQ>
		<SEQ TYPE="LITERAL4">\a</SEQ>
		<SEQ TYPE="LITERAL4">\b</SEQ>
		<SEQ TYPE="LITERAL4">\e</SEQ>
		<SEQ TYPE="LITERAL4">\f</SEQ>
		<SEQ TYPE="LITERAL4">\n</SEQ>
		<SEQ TYPE="LITERAL4">\r</SEQ>
		<SEQ TYPE="LITERAL4">\t</SEQ>
		<SEQ TYPE="LITERAL4">\0</SEQ>
		<SEQ TYPE="LITERAL4">\'</SEQ>
		<SEQ_REGEXP HASH_CHAR="\x" TYPE="LITERAL4">\\x[a-f\d]{2}</SEQ_REGEXP>
		<SEQ_REGEXP HASH_CHAR="\u" TYPE="LITERAL4">\\u[a-f\d]{4}</SEQ_REGEXP>
	</RULES>
</MODE>
