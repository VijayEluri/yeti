// TODO: class, types (typedefs, declarations, casts)

Source    = SP Header? AnyExpression !_;
Header    = "program" !IdChar Space+ ClassName Semicolon /
            "module" !IdChar Space+ ClassName
            (Colon SP "deprecated")? Semicolon;

AnyExpression = Semicolon* Sequence? SP;
Sequence  = Statement (Semicolon Statement?)*; 
Statement = Declaration* (SelfBind / Expression);

Declaration = SP ((Import / Binding) Semicolon+ / Typedef Semicolon*);
Import    = "import" !IdChar Space+ ClassName
            (Colon JavaId SP ("," JavaId SP)*)?;
Typedef   = "typedef" !IdChar SP TypedefOf;
TypedefOf = "unshare" !IdChar SP Id /
            (("opaque" / "shared") !IdChar SP)?
	    Id SP TypedefParam? "=" !OpChar Type;
TypedefParam = "<" !OpChar SP Id SP ("," SP Id SP)* ">" !OpChar SP;

BindId    = SP (Modifier Space)? Id;
Binding   = (StructArg / SP !Any BindId BindArg* IsType)
            SP "=" !OpChar Expression;
SelfBind  = SP (BindId BindArg+ / Any) IsType "=" !OpChar Expression;
Modifier  = "var" / "norec";
BindArg   = SP (Id / "()" / StructArg);
StructArg = "{" BindField ("," BindField)* "}";
BindField = SP Id IsType ("=" !OpChar SP Id)? SP;
Semicolon = SP ";";
Any       = "\_" !IdChar;

Expression = Assign SP ("loop" (!IdChar Assign)?)?;
Assign    = ApplyPipe SP (":=" !OpChar ApplyPipe)?;
ApplyPipe = Cons SP ("|>" !OpChar Cons)* AsIsType*;
AsIsType  = ("is" / "as" / "unsafely\_as") !IdChar Type;
Cons      = StrConcat SP (ConsOp !OpChar StrConcat)*;
ConsOp    = "::" / ":." / "++";
StrConcat = Logical SP ("^" !OpChar Logical)*;
Logical   = Compare SP (("and" / "or") !IdChar Compare)*;
Compare   = SkipSP Not* Compose SP (CompareOp Compose)* SP InstanceOf*;
InstanceOf = "instanceof" !IdChar ClassId SP;
Not       = "not" !IdChar SkipSP;
CompareOp = ("<" / ">" / "<=" / ">=" / "==" / "!=" / "=~" / "!=") !OpChar /
	    "in" !IdChar;
Compose   = CustomOps (ComposeOp CustomOps)*;
ComposeOp = "\." Space+ / Space+ "\." SP;
CustomOps = Sum SkipSP (CustomOp Sum)*;
CustomOp  = !(CompareOp / [*/%+-<=>^:] !OpChar) OpChar+ / IdOp;
Sum       = Multiple SkipSP (SumOp Multiple)*;
SumOp     = ("+" / "-") !OpChar / ("b\_or" / "xor") !IdChar;
Multiple  = Reference+ SkipSP (FactorOp Reference+ SkipSP)*;
FactorOp  = ("*" / "/" / "%") !OpChar /
            ("div" / "shr" / "shl" / "b\_and" / "with") !IdChar;
Reference = SP ("\\" SP / "-" SP !OpChar)* Primitive RefOp*;
RefOp     = FieldRef / MapRef / (SP (ObjectRef / "->" SP Primitive));
FieldRef  = Dot SP (Sym / "``" ^[`]+ "``");
MapRef    = "[" Sequence SP "]";
ObjectRef = "#" JavaId SP ArgList?;

Primitive = Number / String / "(" SP InBrackets ")" / List / Struct /
            Lambda / If / CaseOf / Try / New / Load / ClassOf /
            Variant / Id;
InBrackets = FieldRef+ / SP AsIsType / SP AnyOp Expression /
             Expression SP AnyOp / AnyExpression;

Lambda   = "do" !IdChar BindArg* Colon AnyExpression "done" !IdChar;

If       = "if" !IdChar IfCond ("elif" !IdChar IfCond)* EndIf;
EndIf    = ("else" !IdChar AnyExpression)? "fi" !IdChar /
           "else:" !OpChar Expression;
IfCond   = AnyExpression "then" !IdChar AnyExpression;

CaseOf   = "case" !IdChar AnyExpression "of" !IdChar
	    Case (Semicolon CaseStmt?)* SP Esac;
Case     = SP Pattern Colon Statement;
CaseStmt = Case / Statement / SP "\.\.\." Semicolon* SP &Esac;
Esac     = "esac" !IdChar;
Pattern  = Match SP ("::" !OpChar SP Match SP)*;
Match    = Number / String / JavaId SP "#" SP JavaId / Variant SP Match / Id /
	   "[" SP (Pattern ("," SP Pattern)* ("," SP)?)? "]" /
	   "{" FieldPattern ("," FieldPattern)* ("," SP)? "}" /
	   "(" SP Pattern? ")";
FieldPattern = SP Id IsType ("=" !OpChar SP Pattern)? SP;

Try      = "try" !IdChar AnyExpression Catches "yrt" !IdChar;
Catch    = "catch" !IdChar ClassId (Space Id)? Colon AnyExpression;
Catches  = Finally / Catch+ Finally?;
Finally  = "finally" !IdChar AnyExpression;

New      = "new" !IdChar ClassName SP NewParam;
NewParam = ArgList / "[" AnyExpression "]" "[]"*;
Load     = "load" !IdChar ClassName;
ClassOf  = "classOf" !IdChar ClassName SP "[]"*;
ClassName = JavaId (Dot JavaId)*;
ClassId  = SP "~"? ClassName;
ArgList  = "(" SP (Expression SP ("," Expression SP)*)? ")";
List     = "[:]" / "[" SP (Items ("," SP)?)? "]";
Items    = HashItem ("," HashItem)* / ListItem ("," ListItem)*;
ListItem = Expression SP ("\.\." !OpChar Expression)? SP;
HashItem = Expression Colon Expression SP;
Struct   = "{" Field ("," Field)* ","? SP "}";
Field    = BindId (&(SP [,}]) / BindArg* IsType "=" !OpChar AnyExpression) SP;

IsType   = SP ("is" !IdChar Type)?;
Type     = SP BareType SP ("->" !OpChar SP BareType SP)*;
BareType = ['^] IdChar+ / "~" JavaType / "{" StructType / "(" SP ")" /
           "(" Type ")" / VariantType ("|" !OpChar SP VariantType)* /
	   Sym SP TypeParam?;
VariantType = Variant "\."? !IdChar SP BareType SP;
JavaType = ClassName "[]"*;
TypeParam  = "<" SP (Type ("," Type)*)? ">";
FieldType  = SP ("var" !IdChar SP)? "\."? Sym SP "is" !IdChar Type;
StructType = FieldType ("}" / "," SP "}" / "," StructType);

Colon    = SP ":" !OpChar;
Dot      = "\." / SP "\." !SpChar;
JavaId   = SP ([a-z] / [A-Z] / "\_") ([a-z] / [A-Z] / [0-9] / "\_" / "$")+;

Variant  = [A-Z] IdChar+;
IdOp     = "`" Sym "`";
AnyOp    = !([=:] !OpChar) OpChar+ / IdOp / KeywordOp !IdChar;
Id	 = Sym / "(" SP AnyOp SP ")";
Sym      = !(Keyword !IdChar) ([a-z] / "\_") IdChar*;
IdChar   = [a-z] / [A-Z] / [0-9] / "\_" / "'" / "?" / "$";
SpChar   = [ (),;\\{}];
OpChar   = [!#%&*+-./:<=>@^|~];
Hex      = [0-9] / [a-f] / [A-F];
Number   = ("0" ([xX] Hex+ / [oO] [0-7]+) /
          [0-9]+ ("\." [0-9]+)? ([eE] ([+-]? [0-9]+)?)?);
String   = (("'" ^[']* "'")+ / "\"" (^["\\] / "\\" StringEscape)* "\"");
StringEscape = ["\\abfnrte0] / "u" Hex Hex Hex Hex /
               "(" AnyExpression ")" / [ \t\r\n] SP "\"";

KeywordOp = "and" / "b\_and" / "b\_or" / "div" / "in" / "not" / "or" /
            "shl" / "shr" / "xor";
Keyword  = KeywordOp / "as" / "case" / "catch" / "class" / "classOf" /
           "done" / "do" / "elif" / "else" / "esac" / "fall" / "fi" /
	   "finally" / "if" / "import" / "instanceof" / "is" / "load" /
	   "loop" / "new" / "norec" / "of" / "then" / "try" / "typedef" /
	   "unsafely\_as" / "var" / "with" / "yrt";

LineComment = "//" ^[\r\n]*;
CommentBody = ("/*" CommentBody / !"*/" _)* "*/";
Space    = [ \t\r\n] / LineComment / "/*" CommentBody;
SP       = Space*;
SkipSP   = (Space+ !("\." / "["))?;
