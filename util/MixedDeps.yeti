module yeti.lang.compiler.MixedDeps;

import java.io.File;
import org.apache.tools.ant.taskdefs.Javac;
import org.apache.tools.ant.BuildException;

findFiles path cb is ~File -> (string -> ()) -> () =
    for (wrapArray path#listFiles()) do f:
        if f#isHidden() then // ignore hidden ones
        elif f#isFile() then
            cb f#getPath()
        elif f#isDirectory() and f#getName() !~ '^\.' then
            findFiles f cb
        fi
    done;

cleanJava = substAll
    '(?://[^\n]*+(?:\n|$)|/\*.*?\*/|"(?:[^"\\]|\\.)*+"|\s++)++' ' ';

cleanYeti = substAll
   ('(?://[^\n]*+(?:\n|$)|/\*.*?\*/' ^
    '|"(?:[^"\\\n]|\\\S|\\\s++")*+"' ^
    '|\W(?:is|as|unsafely_as)\s++[\w <>^~($)?'',-]*+' ^
    '|\W(?:''[^''\n]*+'')++|\s+)++') ' ';

loadSource fn =
    readFile fn "ISO-8859-1" getContents;

collectList f =
    map (`at` 1) (collect f () empty?);

ignoreTypes =
    hash ['public', 'private', 'protected', 'String', 'Math', 'System',
          'Thread', 'Character', 'Object', 'Integer', 'Long', 'Double',
          'Number', 'Short', 'Byte', 'Exception', 'Throwable', 'Runnable',
          'Boolean', 'StringBuffer', 'RuntimeException',
          'IllegalArgumentException', 'NullPointerException'];

mapImports imports =
   (importMap = [:];
    for imports do i:
        lastDot = strLastIndexOf' i '.';
        if lastDot > 0 then
            importMap.[strRight i (lastDot + 1)] := ()
        fi
    done;
    importMap);

normalize package importMap t =
   (m = like '^(([a-z_.]+\.)?[A-Z]\w*+)' t ();
    if empty? m or m.[2] == "java.lang." then
        ''
    elif defined? m.[2] then
        m.[1]
    elif m.[1] in importMap or m.[1] in ignoreTypes then
        ''
    else
        "\(package).\(m.[1])"
    fi);

typeFilter package importMap =
    filter (!= '') . map (normalize package importMap) . nub;

javaFile addDeps filename =
   (src = cleanJava (loadSource filename);
    m = like '^(?: *package ([\w.]++);)?((?: *import [^;]++ ?;)*)' src ();
    if not (empty? m) then
        package = m.[1];
        imports = filter (!= '')
                         (matchAll '\Wimport ([\w.]++) ?;' (`at` 1) \'' m.[2]);
        importMap = mapImports imports;
        src = strRight src (strLength m.[0]);
        classes = map (package ^ '.' ^)
                      (collectList (like '\W(?:class|interface) (\w+)' src));
        for classes do className:
            importMap.[className] := ()
        done;
        types = (typeFilter package importMap . concatMap collectList)
                   [like '[(,;] ?(?:final |static )?([\w.]++) \w++ ?[,;=(]' src,
                    like '\W((?:[\w.]+\.)?[A-Z][a-zA-Z]*+)\.\w' src,
                    like '\W(?:new|extends|implements|throws) ([\w.]++)' src];
        addDeps {filename, classes, deps = imports ++ types}
    else
        println "|\(src)|"
    fi);

removeArgs name =
    (like '^(\w+)' name ()).[1];

yetiFile addDeps filename =
   (src = cleanYeti (loadSource filename);
    m = like '^ *(?:module|program) ((?:([\w\.]+)\.)?\w++);' src ();
    if not (empty? m) then
        name = m.[1];
        package = m.[2];
        src = strRight src (strLength m.[0]);
        imports = collectList (like '\W(?:import|load) ([\w.]++)' src);
        importMap = mapImports imports;
        classDefs = collect (like ('\Wclass (\w++)(?:\([^(]*+\))?+ ' ^
                                   '(?:extends (\w++(?:\([^(]*+\))?+' ^
                                   '(?: ?+, ?+\w++(?:\([^(]*+\))?+)*+) )') src)
                            () empty?;
        classes = map ((package ^ '.' ^) . removeArgs . (`at` 1)) classDefs;
        extends = map removeArgs
                      (concatMap (strSplit ' ?, ?' . (`at` 2)) classDefs);
        for classes do className:
            importMap.[className] := ()
        done;
        uses = concatMap collectList [like '([A-Z]\w*+)#' src,
                                      like '\W(?:new|catch) ([\w.]++)' src];
        deps = imports ++ typeFilter package importMap (extends ++ uses);
        addDeps {filename, classes = name :: classes, deps}
    fi);

atFile ctx name =
    if name =~ '\.java$' then
        javaFile ctx name
    elif name =~ '\.yeti$' then
        yetiFile ctx name
    fi;

calculateDeps {fileMap, classMap} =
   (depMap = [:];
    setHashDefault classMap \'';
    forHash fileMap do filename deps:
        depMap.[filename] := filter (_ dep = dep != '' and dep != filename)
                                    (nub (map (at classMap) deps))
    done;
    recurse to deps =
        for deps do dep:
            if not (dep in to) then
                to.[dep] := ();
                recurse to depMap.[dep]
            fi
        done;
    var order = [];
    forHash depMap do filename deps:
        res = [:];
        recurse res deps;
        delete res filename;
        yeti = filename =~ '\.yeti$';
        order := {filename, level = length res, yeti} :: order;
    done;
    order = sortBy (_ a b = if a.level != b.level then
                                a.level < b.level
                            elif a.yeti != b.yeti then
                                b.yeti
                            else
                                a.filename < b.filename
                            fi) order;
    map (map (.filename)) (groupBy (on (==) (.yeti)) order));

addDeps {fileMap, classMap} {filename, classes, deps} =
   (fileMap.[filename] := nub deps;
    for classes do className:
        classMap.[className] := filename
    done);

/*
srcdir = shift _argv;

startTime = System#currentTimeMillis();
println "Scanning sources...";

sources = array [];
findFiles new File(srcdir) (push sources);
*/

scanSources sources = 
   (ctx = {fileMap = [:], classMap = [:]};
    for sources (atFile (addDeps ctx));
    calculateDeps ctx);

plurals l =
    if length l == 1 then "" else "s" fi;

class MixedCompileTask extends Javac
    void execute()
        this#checkParameters();
        this#resetFileLists();

        srcdir = this#getSrcdir();
        destdir = this#getDestdir();
        sources = array [];
        for (wrapArray srcdir#list()) do src:
            dir = this#getProject()#resolveFile(src);
            if not dir#exists() then
                throw new BuildException("No srcdir=\"\(dir)\"",
                                         this#getLocation())
            fi;
            files = this#getDirectoryScanner(dir)#getIncludedFiles();
            for (wrapArray files) do name:
                push sources "\(new File(dir, name))"
            done
        done;
        this#log("Scanning \(length sources) source file" ^ plurals sources);
        ordered = scanSources sources;
        toFile name = new File(name is string);
        for ordered do files:
            if head files =~ '\.yeti$' then
                this#log("Compiling \(length files) yeti source file" ^
                         plurals files);
            else
                this#compileList := map toFile files as ~File[];
                this#compile()
            fi
        done
end
