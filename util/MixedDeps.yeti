program MixedDeps;

import java.io.File;

srcdir = shift _argv;

findFiles path cb is ~File -> 'a =
    for (wrapArray path#listFiles()) do f:
        if f#isHidden() then // ignore hidden ones
        elif f#isFile() then
            cb f#getPath()
        elif f#isDirectory() and f#getName() !~ '^\.' then
            findFiles f cb
        fi
    done;

cleanJava = substAll
    '(?://[^\n]*(?:\n|$)|/\*.*?\*/|"(?:[^"\\]|\\.")"|\s+)+' ' ';

cleanYeti = substAll
   '(?://[^\n]*(?:\n|$)|/\*.*?\*/|"(?:[^"\\]|\\\S|\\\s+")"|''[^'']*.|\s+)+' ' ';

loadSrc fn =
    readFile fn "ISO-8859-1" getContents;

collectList f =
    map (`at` 1) (collect f () empty?);

ignoreTypes =
    hash ['public', 'private', 'protected', 'String', 'Math', 'System',
          'Thread', 'Character', 'Object', 'Integer', 'Long', 'Double',
          'Number', 'Short', 'Byte', 'Exception', 'Throwable', 'Runnable',
          'Boolean', 'StringBuffer', 'RuntimeException',
          'IllegalArgumentException', 'NullPointerException'];

mapImports imports =
   (importMap = [:];
    for imports do i:
        lastDot = strLastIndexOf' i '.';
        if lastDot > 0 then
            importMap.[strRight i (lastDot + 1)] := ()
        fi
    done;
    importMap);

normalize package importMap t =
   (m = like '^(([a-z_.]+\.)?[A-Z]\w*)' t ();
    if empty? m then
        ''
    elif defined? m.[2] then
        m.[1]
    elif m.[1] in importMap or m.[1] in ignoreTypes then
        ''
    else
        "\(package).\(m.[1])"
    fi);

typeFilter package importMap =
    filter (!= '') . map (normalize package importMap)
                   . nub
                   . concatMap collectList;

javaFileMap = [:];

javaFile classMap fileName =
   (src = ' ' ^ cleanJava (loadSrc fileName);
    m = like '^(?: package ([\w.]+);)?((?: ?import [^;]+ ?;)*)' src ();
    if not (empty? m) then
        package = m.[1];
        imports =
            filter (!= '') (matchAll '\Wimport ([\w.]+) ?;' (`at` 1) \'' m.[2]);
        importMap = mapImports imports;
        src = strRight src (strLength m.[0]);
        classes = map (package ^ "." ^)
                      (collectList (like '\W(?:class|interface) (\w+)' src));
        for classes do className:
            importMap.[className] := ()
        done;
        types = typeFilter package importMap
                    [like '[(,;] ?(?:final |static )?([\w.]+) \w+ ?[,;=(]' src,
                     like '\W((?:[\w.]+\.)?[A-Z][a-zA-Z]*)\.\w' src,
                     like '\W(?:new|extends|implements|throws) ([\w.]+)' src];
        deps = nub (imports ++ types);
        /*println "JAVA \(fileName)";
        println "Package: \(package)";
        println "Classes: \(classes)";
        println "Uses: \(deps)";*/
        javaFileMap.[fileName] := deps;
        for classes do className:
            classMap.[className] := fileName
        done;
    else
        println src;
    fi);

yetiFile fn =
   (src = cleanYeti (loadSrc fn);
    m = like '^ ?(?:module|program) (?:([\w\.]+)\.)?(\w+);' src ();
    if not (empty? m) then
        package = m.[1];
        name = m.[2];
        src = strRight src (strLength m.[0]);
        imports = collectList (like '\W(?:import|load) ([\w.]+)[^\w.]');
        classDefs = collect (like
        println "YETI: \(package) \(name)";
    fi);

classMap = [:];

atFile name =
    if name =~ '\.java$' then
        javaFile classMap name
    elif name =~ '\.yeti$' then
        yetiFile name
    fi;

findFiles new File(srcdir) atFile;

calculateDeps fileMap classMap =
   (depMap = [:];
    setHashDefault classMap \'';
    forHash fileMap do fileName deps:
        depMap.[fileName] := filter (_ dep = dep != '' and dep != fileName)
                                    (nub (map (at classMap) deps))
    done;
    recurse to deps =
        for deps do dep:
            if not (dep in to) then
                to.[dep] := ();
                recurse to depMap.[dep]
            fi
        done;
    var order = [];
    forHash depMap do fileName deps:
        res = [:];
        recurse res deps;
        order := { fileName, level = length res } :: order;
    done;
    order = sortBy (_ a b = if a.level == b.level then
                                a.fileName < b.fileName
                            else
                                a.level < b.level
                            fi) order;
    map (.fileName) order);

order = calculateDeps javaFileMap classMap;
for order println;

