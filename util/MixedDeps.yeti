program MixedDeps;

import java.io.File;

srcdir = shift _argv;

findFiles path cb is ~File -> 'a =
    for (wrapArray path#listFiles()) do f:
        if f#isHidden() then // ignore hidden ones
        elif f#isFile() then
            cb f#getPath()
        elif f#isDirectory() and f#getName() !~ '^\.' then
            findFiles f cb
        fi
    done;

cleanJava = substAll
    '(?://[^\n]*(?:\n|$)|/\*.*?\*/|"(?:[^"\\]|\\.")"|\s+)+' ' ';

//'(?://[^\n]*(?:\n|$)|/\*.*?\*/|"(?:[^"\\]|\\\S|\\\s+")"|''[^'']*.|\s+)+'
cleanYeti = substAll
   ('(?://[^\n]*(?:\n|$)|/\*.*?\*/' ^
    '|"(?:[^"\\]|\\\S|\\\s+")"' ^
    '|\W(?:is|as|unsafely_as)\s+[\w\s_<>^~($)?'',-]*' ^
    '|''[^'']*.|\s+)+') ' ';

loadSrc fn =
    readFile fn "ISO-8859-1" getContents;

collectList f =
    map (`at` 1) (collect f () empty?);

ignoreTypes =
    hash ['public', 'private', 'protected', 'String', 'Math', 'System',
          'Thread', 'Character', 'Object', 'Integer', 'Long', 'Double',
          'Number', 'Short', 'Byte', 'Exception', 'Throwable', 'Runnable',
          'Boolean', 'StringBuffer', 'RuntimeException',
          'IllegalArgumentException', 'NullPointerException'];

mapImports imports =
   (importMap = [:];
    for imports do i:
        lastDot = strLastIndexOf' i '.';
        if lastDot > 0 then
            importMap.[strRight i (lastDot + 1)] := ()
        fi
    done;
    importMap);

normalize package importMap t =
   (m = like '^(([a-z_.]+\.)?[A-Z]\w*)' t ();
    if empty? m or m.[2] == "java.lang." then
        ''
    elif defined? m.[2] then
        m.[1]
    elif m.[1] in importMap or m.[1] in ignoreTypes then
        ''
    else
        "\(package).\(m.[1])"
    fi);

typeFilter package importMap =
    filter (!= '') . map (normalize package importMap) . nub;

javaFileMap = [:];

addDeps classMap fileName classes deps =
   (javaFileMap.[fileName] := nub deps;
    //println "\(fileName) uses: \(deps)";
    for classes do className:
        classMap.[className] := fileName
    done);

javaFile classMap fileName =
   (src = cleanJava (loadSrc fileName);
    m = like '^(?: *package ([\w.]+);)?((?: *import [^;]+ ?;)*)' src ();
    if not (empty? m) then
        package = m.[1];
        imports =
            filter (!= '') (matchAll '\Wimport ([\w.]+) ?;' (`at` 1) \'' m.[2]);
        importMap = mapImports imports;
        src = strRight src (strLength m.[0]);
        classes = map (package ^ '.' ^)
                      (collectList (like '\W(?:class|interface) (\w+)' src));
        for classes do className:
            importMap.[className] := ()
        done;
        types = (typeFilter package importMap . concatMap collectList)
                    [like '[(,;] ?(?:final |static )?([\w.]+) \w+ ?[,;=(]' src,
                     like '\W((?:[\w.]+\.)?[A-Z][a-zA-Z]*)\.\w' src,
                     like '\W(?:new|extends|implements|throws) ([\w.]+)' src];
        //println "JAVA \(fileName)";
        //println "Package: \(package)";
        //println "Classes: \(classes)";
        addDeps classMap fileName classes (imports ++ types);
    else
        println "|\(src)|";
    fi);

removeArgs name =
    (like '^(\w+)' name ()).[1];

yetiFile classMap fn =
   (src = cleanYeti (loadSrc fn);
    m = like '^ *(?:module|program) ((?:([\w\.]+)\.)?\w+);' src ();
    if not (empty? m) then
        fullName = m.[1];
        package = m.[2];
        src = strRight src (strLength m.[0]);
        imports = collectList (like '\W(?:import|load) ([\w.]+)' src);
        importMap = mapImports imports;
        classDefs = collect (like ('\Wclass (\w+)(?:\([^(]*\))? ' ^
                                   '(?:extends (\w+(?:\([^(]*\))?' ^
                                   '(?: ?, ?\w+(?:\([^(]*\))?)*) )') src)
                            () empty?;
        classes = map ((package ^ '.' ^) . removeArgs . (`at` 1)) classDefs;
        extends = map removeArgs
                      (concatMap (strSplit ' ?, ?' . (`at` 2)) classDefs);
        for classes do className:
            importMap.[className] := ()
        done;
        uses = concatMap collectList [like '([A-Z]\w*)#' src,
                                      like '\W(?:new|catch) ([\w.]+)' src];
        deps = imports ++ typeFilter package importMap (extends ++ uses);
        //println "YETI: \(package) \(name)";
        //println "classes: \(classes)";
        addDeps classMap fn (fullName :: classes) deps;
    fi);

classMap = [:];

atFile name =
    if name =~ '\.java$' then
        javaFile classMap name
    elif name =~ '\.yeti$' then
        yetiFile classMap name
    fi;

findFiles new File(srcdir) atFile;

calculateDeps fileMap classMap =
   (depMap = [:];
    setHashDefault classMap \'';
    forHash fileMap do fileName deps:
        depMap.[fileName] := filter (_ dep = dep != '' and dep != fileName)
                                    (nub (map (at classMap) deps))
    done;
    recurse to deps =
        for deps do dep:
            if not (dep in to) then
                to.[dep] := ();
                recurse to depMap.[dep]
            fi
        done;
    var order = [];
    forHash depMap do fileName deps:
        res = [:];
        recurse res deps;
        delete res fileName;
        order := { fileName, level = length res } :: order;
    done;
    order = sortBy (_ a b = if a.level == b.level then
                                a.fileName < b.fileName
                            else
                                a.level < b.level
                            fi) order;
    map (.fileName) order);

order = calculateDeps javaFileMap classMap;
for order println;

