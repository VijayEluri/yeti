module yeti.ant.MixedDeps;

import java.io.File;
import org.apache.tools.ant.taskdefs.Javac;
import org.apache.tools.ant.BuildException;

cleanJava = substAll
    '(?://[^\n]*+(?:\n|$)|/\*.*?\*/|"(?:[^"\\]|\\.)*+"|\s++)++' ' ';

cleanYeti = substAll
   ('(?://[^\n]*+(?:\n|$)|/\*.*?\*/' ^
    '|"(?:[^"\\\n]|\\\S|\\\s++")*+"' ^
    '|\W(?:is|as|unsafely_as)\s++[\w <>^~($)?'',-]*+' ^
    '|\W(?:''[^''\n]*+'')++|\s+)++') ' ';

loadSource fn =
    readFile fn "ISO-8859-1" getContents;

collectList f =
    map (`at` 1) (collect f () empty?);

ignoreTypes =
    hash ['public', 'private', 'protected', 'String', 'Math', 'System',
          'Thread', 'Character', 'Object', 'Integer', 'Long', 'Double',
          'Number', 'Short', 'Byte', 'Exception', 'Throwable', 'Runnable',
          'Boolean', 'StringBuffer', 'RuntimeException',
          'IllegalArgumentException', 'NullPointerException'];

mapImports imports =
   (importMap = [:];
    for imports do i:
        lastDot = strLastIndexOf' i '.';
        if lastDot > 0 then
            importMap.[strRight i (lastDot + 1)] := ()
        fi
    done;
    importMap);

normalize package importMap t =
   (m = like '^(([a-z_.]+\.)?[A-Z]\w*+)' t ();
    if empty? m or m.[2] == "java.lang." then
        ''
    elif defined? m.[2] then
        m.[1]
    elif m.[1] in importMap or m.[1] in ignoreTypes then
        ''
    else
        package ^ m.[1]
    fi);

typeFilter package importMap =
    filter (!= '') . map (normalize package importMap) . nub;

javaFile addDeps filename =
   (src = cleanJava (loadSource filename);
    m = like '^(?: *package ([\w.]++);)?((?: *import [^;]++ ?;)*)' src ();
    if not (empty? m) then
        package = if m.[1] == '' then
                      ''
                  else
                      m.[1] ^ '.'
                  fi;
        imports = filter (!= '')
                         (matchAll '\Wimport ([\w.]++) ?;' (`at` 1) \'' m.[2]);
        importMap = mapImports imports;
        src = strRight src (strLength m.[0]);
        classes = map (package ^)
                      (collectList (like '\W(?:class|interface) (\w+)' src));
        for classes do className:
            importMap.[className] := ()
        done;
        types = (typeFilter package importMap . concatMap collectList)
                   [like '[(,;] ?(?:final |static )?([\w.]++) \w++ ?[,;=(]' src,
                    like '\W((?:[\w.]+\.)?[A-Z][a-zA-Z]*+)\.\w' src,
                    like '\W(?:new|extends|implements|throws) ([\w.]++)' src];
        name = like '(?i)(\w+)\.java$' filename ();
        name = if empty? name then
                   ''
               else
                   package ^ name.[1]
               fi;
        target = if name != '' and (empty? classes or
                                    any (on (==) strLower name) classes) then
                     name
                 elif not (empty? classes) then
                     head classes
                 else
                     ''
                 fi;
        addDeps {filename, classes, deps = imports ++ types, target}
    fi);

removeArgs name =
    (like '^(\w+)' name ()).[1];

yetiFile addDeps filename =
   (src = cleanYeti (loadSource filename);
    m = like '^ *(?:module|program) (([\w\.]+\.)?\w++);' src ();
    if not (empty? m) then
        name = m.[1];
        package = m.[2];
        src = strRight src (strLength m.[0]);
        imports = collectList (like '\W(?:import|load) ([\w.]++)' src);
        importMap = mapImports imports;
        classDefs = collect (like ('\Wclass (\w++)(?:\([^(]*+\))?+ ' ^
                                   '(?:extends (\w++(?:\([^(]*+\))?+' ^
                                   '(?: ?+, ?+\w++(?:\([^(]*+\))?+)*+) )') src)
                            () empty?;
        classes = map ((package ^ ) . removeArgs . (`at` 1)) classDefs;
        extends = map removeArgs
                      (concatMap (strSplit ' ?, ?' . (`at` 2)) classDefs);
        for classes do className:
            importMap.[className] := ()
        done;
        uses = concatMap collectList [like '([A-Z]\w*+)#' src,
                                      like '\W(?:new|catch) ([\w.]++)' src];
        deps = imports ++ typeFilter package importMap (extends ++ uses);
        addDeps {filename, classes = name :: classes, deps, target = name}
    fi);

atFile ctx name =
    if name =~ '\.java$' then
        javaFile ctx name
    elif name =~ '\.yeti$' then
        yetiFile ctx name
    fi;

calculateDeps classPathModified targetDir {fileMap, classMap} =
   (depMap = [:];
    setHashDefault classMap \'';
    forHash fileMap do filename {deps}:
        depMap.[filename] := filter (_ dep = dep != '' and dep != filename)
                                    (nub (map (at classMap) deps))
    done;
    recurse to deps =
        for deps do dep:
            if not (dep in to) then
                to.[dep] := ();
                recurse to depMap.[dep]
            fi
        done;
    var order = [];
    forHash depMap do filename deps:
        res = [:];
        recurse res deps;
        delete res filename;
        yeti = filename =~ '\.yeti$';
        order := {filename, level = length res, yeti} :: order;
    done;
    order = sortBy (_ a b = if a.level != b.level then
                                a.level < b.level
                            elif a.yeti != b.yeti then
                                b.yeti
                            else
                                a.filename < b.filename
                            fi) order;
    dirty {filename} =
       ({modified, target} = fileMap.[filename];
        classFile = new File(targetDir is ~File,
                             strReplace '.' File#separator target ^ ".class");
        classFile#lastModified() <= max modified classPathModified);
    // everything starting from dirty same-level group needs to be built
    byLevel = groupBy (on (==) (.level)) order;
    build   = concat  (find (any dirty) byLevel);
    byLang  = groupBy (on (==) (.yeti)) build;
    map (map (.filename)) byLang);

lastModified filename is string -> number =
    new File(filename)#lastModified();

addDeps {fileMap, classMap} {filename is string, classes, deps, target} =
   (modified = lastModified filename;
    fileMap.[filename] := {deps = nub deps, modified, target};
    for classes do className:
        classMap.[className] := filename
    done);

scanSources classPath targetDir sources = 
   (classPathModified = fold max 0 (map lastModified classPath);
    ctx = {fileMap = [:], classMap = [:]};
    for sources (atFile (addDeps ctx));
    calculateDeps classPathModified targetDir ctx);

plurals l =
    if length l == 1 then "" else "s" fi;

antError =
    "Compile failed; see the compiler error output for details.";

class MixedCompileTask extends Javac
    void execute()
        this#checkParameters();
        this#resetFileLists();

        srcdir = this#getSrcdir();
        destdir = this#getDestdir();
        sources = array [];
        for (wrapArray srcdir#list()) do src:
            dir = this#getProject()#resolveFile(src);
            if not dir#exists() then
                throw new BuildException("No srcdir=\"\(dir)\"",
                                         this#getLocation())
            fi;
            files = this#getDirectoryScanner(dir)#getIncludedFiles();
            for (wrapArray files) do name:
                if name =~ '\.java$|\.yeti$' then
                    push sources "\(new File(dir, name))"
                fi
            done
        done;
        this#log("Scanning \(length sources) source file" ^ plurals sources);
        classPath = map string (wrapArray this#getClasspath()#list());
        order = scanSources classPath destdir sources;
        toFile name = new File(name is string);
        // lazy to avoid unnecessary initialisation of yeti compiler
        compileYeti = lazy do:
            yetic = load yeti.lang.compiler.repl (array []);
            yetic.gcj := true; // extra casts for safety
            yetic.classPath := classPath;
            do files:
                yetic.compileToFiles files "\(destdir)" do err:
                    this#log(err#getMessage())
                done
            done
        done;
        this#setFailonerror(true);
        for order do files:
            if head files =~ '\.yeti$' then
                this#log("Compiling \(length files) yeti source" ^
                         plurals files ^ " to " ^ destdir);
                if not (compileYeti () files) then
                    throw new BuildException(antError, this#getLocation())
                fi
            else
                this#compileList := map toFile files as ~File[];
                this#compile()
            fi
        done
end
