module yeti.ant.MixedDeps;

import java.io.File;
import org.apache.tools.ant.taskdefs.Javac;
import org.apache.tools.ant.BuildException;
import java.lang.Class;
import java.lang.Number;

cleanJava = substAll
    '(?://[^\n]*+(?:\n|$)|/\*.*?\*/|"(?:[^"\\]|\\.)*+"|\s++)++' ' ';

cleanYeti = substAll
   ('(?://[^\n]*+(?:\n|$)|/\*.*?\*/' ^
    '|"(?:[^"\\\n]|\\\S|\\\s++")*+"' ^
    '|\W(?:is|as|unsafely_as)\s++[\w <>^~($)?'',-]*+' ^
    '|\W(?:''[^''\n]*+'')++|\s+)++') ' ';

loadSource fn =
    readFile fn "ISO-8859-1" getContents;

collectList f =
    map (`at` 1) (collect f () empty?);

ignoreTypes =
    hash ['public', 'private', 'protected', 'String', 'Math', 'System',
          'Thread', 'Character', 'Object', 'Integer', 'Long', 'Double',
          'Number', 'Short', 'Byte', 'Exception', 'Throwable', 'Runnable',
          'Boolean', 'StringBuffer', 'RuntimeException',
          'IllegalArgumentException', 'NullPointerException'];

mapImports imports =
   (importMap = [:];
    for imports do i:
        lastDot = strLastIndexOf' i '.';
        if lastDot > 0 then
            importMap.[strRight i (lastDot + 1)] := ()
        fi
    done;
    importMap);

normalize package importMap t =
   (m = like '^(([a-z_.]+\.)?[A-Z]\w*+)' t ();
    if empty? m or m.[2] == "java.lang." then
        ''
    elif defined? m.[2] then
        m.[1]
    elif m.[1] in importMap or m.[1] in ignoreTypes then
        ''
    else
        package ^ m.[1]
    fi);

typeFilter package importMap =
    filter (!= '') . map (normalize package importMap) . nub;

javaFile addDeps filename =
   (src = cleanJava (loadSource filename);
    m = like '^(?: *package ([\w.]++);)?((?: *import [^;]++ ?;)*)' src ();
    if not (empty? m) then
        package = if m.[1] == '' then
                      ''
                  else
                      m.[1] ^ '.'
                  fi;
        imports = filter (!= '')
                         (matchAll '\Wimport ([\w.]++) ?;' (`at` 1) \'' m.[2]);
        importMap = mapImports imports;
        src = strRight src (strLength m.[0]);
        classes = map (package ^)
                      (collectList (like '\W(?:class|interface) (\w+)' src));
        for classes do className:
            importMap.[className] := ()
        done;
        types = (typeFilter package importMap . concatMap collectList)
                   [like ('[{(,;] ?(?:final |static )?' ^
                          '([\w.]++) \w++(?= ?[,;=()])') src,
                    like '\W((?:[\w.]+\.)?[A-Z][a-zA-Z]*+)\.\w' src,
                    like '\( ?([A-Z][a-zA-Z]*+) ?\)' src,
                    like '\W(?:new|extends|implements|throws) ([\w.]++)' src];
        name = like '(?i)(\w+)\.java$' filename ();
        name = if empty? name then
                   ''
               else
                   package ^ name.[1]
               fi;
        target = if name != '' and (empty? classes or
                                    any (on (==) strLower name) classes) then
                     name
                 elif not (empty? classes) then
                     head classes
                 else
                     ''
                 fi;
        //println "\(filename): \(imports)";
        addDeps {filename, classes, deps = imports ++ types, target}
    fi);

removeArgs name =
    (like '^[.\w]+' name ()).[0];

argPattern = like
    '\w\(((?:\w++\.)*+[A-Z]\w*+ ++\w++(?:,\s*+(?:\w++\.)*+[A-Z]\w*+ ++\w++)*+)\)';

yetiFile addDeps filename =
   (src = cleanYeti (loadSource filename);
    m = like '^ *(?:module|program) (([\w\.]+\.)?\w++);' src ();
    if not (empty? m) then
        name = m.[1];
        package = m.[2];
        src = strRight src (strLength m.[0]);
        imports = collectList (like '\W(?:import|load) ([\w.]++)' src);
        importMap = mapImports imports;
        classDefs = collect (like ('\Wclass (\w++)(?:\([^)]*+\))?+ ' ^
                                   '(?:extends (\w++(?:\([^)]*+\))?+' ^
                                   '(?: ?+, ?+\w++)*+) )?+(.*?)end') src)
                            () empty?;
        classes = map ((package ^ ) . removeArgs . (`at` 1)) classDefs;
        extends =
            map removeArgs
                (filter (!= '')
                        (concatMap (strSplit ' ?, ?' . (`at` 2)) classDefs));
        for classes do className:
            importMap.[className] := ()
        done;
        uses = concatMap collectList [like '([A-Z]\w*+)#' src,
                                      like '\W(?:new|catch) ([\w.]++)' src];
        args = concatMap (collectList . argPattern . (`at` 3)) classDefs;
        args = map removeArgs (concatMap (strSplit ' *, *') args);
        deps = imports ++ typeFilter package importMap (extends ++ uses ++ args);
        //println "\(filename): \(classes)";
        addDeps {filename, classes = name :: classes, deps, target = name}
    fi);

atFile ctx name =
    if name =~ '\.java$' then
        javaFile ctx name
    elif name =~ '\.yeti$' then
        yetiFile ctx name
    fi;

calculateDeps classPathModified targetDir {fileMap, classMap} =
   (depMap = [:];
    setHashDefault classMap \'';
    forHash fileMap do filename {deps}:
        depMap.[filename] := filter (_ dep = dep != '' and dep != filename)
                                    (nub (map (at classMap) deps))
    done;
    recurse to deps =
        for deps do dep:
            if not (dep in to) then
                to.[dep] := ();
                recurse to depMap.[dep]
            fi
        done;
    var order = [];
    forHash depMap do filename deps:
        res = [:];
        recurse res deps;
        delete res filename;
        yeti = filename =~ '\.yeti$';
        order := {filename, level = length res, yeti} :: order;
    done;
    order = sortBy (_ a b = if a.level != b.level then
                                a.level < b.level
                            elif a.yeti != b.yeti then
                                b.yeti
                            else
                                a.filename < b.filename
                            fi) order;
    dirty {filename} =
       ({modified, target} = fileMap.[filename];
        classFile = new File(targetDir is ~File,
                             strReplace '.' File#separator target ^ ".class");
        classFile#lastModified() <= max modified classPathModified);
    // everything starting from dirty same-level group needs to be built
    byLevel = groupBy (on (==) (.level)) order;
    build   = concat  (find (any dirty) byLevel);
    byLang  = groupBy (on (==) (.yeti)) build;
    //for byLang println;
    map (map (.filename)) byLang);

lastModified filename is string -> number =
    new File(filename)#lastModified();

addDeps {fileMap, classMap} {filename is string, classes, deps, target} =
   (modified = lastModified filename;
    //println "\(filename): \(deps)";
    fileMap.[filename] := {deps = nub deps, modified, target};
    for classes do className:
        classMap.[className] := filename
    done);

scanSources classPath targetDir sources = 
   (classPathModified = fold max 0 (map lastModified classPath);
    ctx = {fileMap = [:], classMap = [:]};
    for sources (atFile (addDeps ctx));
    calculateDeps classPathModified targetDir ctx);

plurals l =
    if length l == 1 then "" else "s" fi;

antError =
    "Compile failed; see the compiler error output for details.";

doCompile {classPath, destdir, sources, javaArgs, log, error, exception} =
   (log "Scanning \(length sources) source file\(plurals sources)";
    order = scanSources classPath destdir sources;
    classPath = classPath ++ ["\(destdir)"];
    // lazy to avoid unnecessary initialisation of yeti compiler
    compileYeti = lazy do:
        yetic = load yeti.lang.compiler.repl (array []);
        yetic.gcj := true; // extra casts for safety
        yetic.classPath := classPath;
        do files:
            yetic.compileToFiles files "\(destdir)" do err:
                log err#getMessage()
            done
        done
    done;
    for order do files:
        if head files =~ '\.yeti$' then
            log "Compiling \(length files) yeti \
                "source\(plurals files) to \(destdir)";
            if not (compileYeti () files) then
                error antError
            fi
        else
            log "Compiling \(length files) java \
                "source\(plurals files) to \(destdir)";
            args = array javaArgs;
            if not (empty? classPath) then
                push args "-classpath";
                push args (strJoin File#pathSeparator classPath);
            fi;
            push args "-d";
            push args "\(destdir)";
            for files (push args);
            result =
                try
                    c = Class#forName("com.sun.tools.javac.Main");
                    compiler = c#newInstance();
                    compile = c#getMethod("compile",
                                    [Class#forName('[Ljava.lang.String;')]);
                    compile#invoke(compiler, [args as ~String[]])
                catch Exception ex:
                    exception "Error starting compiler" ex
                yrt;
            if (result unsafely_as ~Number)#intValue() != 0 then
                error antError
            fi
        fi
    done);

class MixedCompileTask extends Javac
    void execute()
        this#checkParameters();
        this#resetFileLists();

        srcdir = this#getSrcdir();
        destdir = this#getDestdir();
        sources = array [];
        for srcdir#list() do src:
            dir = this#getProject()#resolveFile(src);
            if not dir#exists() then
                throw new BuildException("No srcdir=\"\(dir)\"",
                                         this#getLocation())
            fi;
            files = this#getDirectoryScanner(dir)#getIncludedFiles();
            for files do name:
                if name =~ '\.java$|\.yeti$' then
                    push sources "\(new File(dir, name))"
                fi
            done
        done;
        classPath = map string this#getClasspath()#list();
        javaArgs = array [];
        if this#getDeprecation() then
            push javaArgs "-deprecation"
        fi;
        if this#getDebug() then
            push javaArgs "-g"
        fi;
        if defined? this#getEncoding() then
            push javaArgs "-encoding";
            push javaArgs this#getEncoding()
        fi;
        if defined? this#getSource() then
            push javaArgs "-source";
            push javaArgs this#getSource()
        fi;
        if defined? this#getTarget() then
            push javaArgs "-target";
            push javaArgs this#getTarget()
        fi;
        if this#getVerbose() then
            push javaArgs "-verbose"
        fi;
        this#setFailonerror(true);
        doCompile {
            classPath, destdir, sources, javaArgs,

            log msg =
                this#log(msg),
            error msg is string -> () =
                throw new BuildException(msg, this#getLocation()),
            exception msg ex =
                throw new BuildException(msg, ex is ~Exception, this#getLocation())
        }
end;

{
    mixedCompile args =
        sourceDirs = array [];
        classPath = array [];
        javaArgs = array [];
        var destdir = '.';
        var op = push sourceDirs;
        for args do arg:
            if arg == '-cp' then
                op := (`for` push classPath) . strSplit File#pathSeparator
            elif arg == '-d' then
                op := do dir: destdir := dir done
            elif arg == '-encoding' or arg == '-source' or arg == '-target' then
                push javaArgs arg;
                op := push javaArgs
            elif arg == '-g' or arg == '-deprecation' or arg == '-verbose' then
                push javaArgs arg
            else
                op arg;
                op := push sourceDirs
            fi
        done;
        sources = array [];
        scanDir dir is ~File -> () =
            for dir#listFiles() do f:
                if f#isDirectory() then
                    scanDir f
                else
                    name = f#getPath();
                    if name =~ '\.java$|\.yeti$' then
                        push sources name
                    fi
                fi
            done;
        for sourceDirs do sourceDir:
            f = new File(sourceDir);
            if f#isFile() then
                push sources sourceDir
            else
                scanDir f
            fi
        done;
        doCompile {
            sources, javaArgs,
            classPath = list classPath,
            destdir = new File(destdir),
            log = println,
            exception msg ex =
                throw new RuntimeException(msg, ex is ~Exception),
            error msg = 
                System#err#println(msg);
                sysExit 1
        }
}
