asort f less l =
   (a = array l;
    f less a;
    asList a);

selectionSort less a =
   (selectLess i j = if less a.[i] a.[j] then i else j fi;
    swapMin i = swapAt a i (fold selectLess i [i + 1 .. length a - 1]);
    for [0 .. length a - 2] swapMin);

combSort less a =
   (var gap = length a;
    var swapped = true;
    gap > 1 or swapped loop
       (gap := gap * 10 div 13;
        if gap == 10 or gap == 9 then
            gap := 11
        elif gap < 1 then
            gap := 1
        fi;
        swapped := false;
        for [0 .. length a - gap - 1] do i:
            if less a.[i + gap] a.[i] then
                swapAt a i (i + gap);
                swapped := true
            fi
        done));

shellSort less a =
   (var inc = length a;
    (inc := if inc == 2 then 1 else inc * 10 div 23 fi; inc > 0) loop
       (var i = inc;
        i < length a loop
           (tmp = a.[i];
            var j = i;
            j >= inc and less tmp a.[j - inc] loop
               (a.[j] := a.[j - inc];
                j := j - inc);
            a.[j] := tmp;
            i := i + 1)));

// based on wikipedia pseudocode example
heapSort less a =
   (count = length a;
    var end = 1;
    end < count loop // heapify
       (var child = end;
        child > 0 loop
           (parent = (child - 1) div 2;
            if less a.[parent] a.[child] then
                swapAt a parent child;
                child := parent
            else
                child := 0
            fi);
        end := end + 1);
    end := count - 1;
    end > 0 loop
       (swapAt a 0 end;
        end := end - 1;
        var root = 0;
        root * 2 + 1 <= end loop // shiftdown
           (var child = root * 2 + 1;
            if child < end and a.[child] < a.[child + 1] then
                child := child + 1
            fi;
            if less a.[root] a.[child] then
                swapAt a root child;
                root := child
            else
                root := end
            fi)));

qsort less a =
   (sort l r =
       (var i = l;
        var j = r;
        x = a.[(l + r) div 2];
           (less a.[i] x loop i := i + 1;
            less x a.[j] loop j := j - 1;
            if i <= j then
                swapAt a i j;
                i := i + 1;
                j := j - 1;
            fi;
            i <= j) loop;
        if l < j then
            sort l j
        fi;
        if i < r then
            sort i r
        fi)) 0 (length a - 1);

qsort2 less =
   (qsort l =
        case l of
        x :: xs: // could do with half of the compares
            qsort (filter (not . less x) xs) ++ x :: qsort (filter (less x) xs);
        _: [];
        esac);

mergeSort less l =
   (merge l a b =
        if empty? a then
            revAppend l b
        elif empty? b then
            revAppend l a
        elif less (head a) (head b) then
            merge (head a :: l) (tail a) b
        else
            merge (head b :: l) a (tail b)
        fi;
    sort list len =
        if len <= 1 then
            list
        else
            left = len div 2;
            {fst, snd} = splitAt left list;
            merge [] (sort fst left) (sort snd (len - left))
        fi) l (length l);

insertionSort less l =
    fold do l e:
        {fst, snd} = splitBy (not . (`less` e)) l;
        fst ++ e :: snd
    done [] l;

insertionSort2 less a =
    for [1 .. length a - 1] do i:
        v = a.[i];
        var j = i - 1;
        j >= 0 and less v a.[j] loop
           (a.[j + 1] := a.[j];
            j := j - 1);
        a.[j + 1] := v
    done;

l = map \(randomInt 3000) [1..1500];
sorted = sort l;

testSort name f =
   (var n = 0; // number of comparisions
    less x y = (n := n + 1; x < y);
    t' = System#currentTimeMillis();
    r = f less l;
    _ = length r; // force lists so n would have correct value
    t = System#currentTimeMillis() - t';
    if sorted != r then
        println "\(name): ERROR\n\(r) != \(sorted)"
    else
        println "\(name):\(n)\t\(t)ms"
    fi);

testASort name f = testSort name (asort f);

println "sorting array of \(length l) elements...";
testASort "selection" selectionSort;
testSort "insertion" insertionSort;
testASort "insertion2" insertionSort2;
testASort "shell" shellSort;
testASort "comb" combSort;
testASort "heap" heapSort;
testASort "qsort" qsort;
testSort "qsort2" qsort2;
testSort "merge" mergeSort;
testSort "sortBy" sortBy;

