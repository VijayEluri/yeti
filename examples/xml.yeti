//module yeti.xml;
module xml;

import javax.xml.stream: XMLInputFactory, XMLOutputFactory, XMLStreamReader,
                         XMLStreamWriter, XMLStreamConstants;

typedef xml_value =
    PCData string | CData string | Comment string | DTD string

typedef xmlns_declaration = {
    prefix is string,
    uri is string
}

typedef xml_element = {
    name is string,
    attributes is hash<string, string>, // empty for text node
    elements is array<xml_element>, // child elements (empty for text node)
    var text is string,             // all text concatenated in this element
    var values is list<xml_value>,  // non-element nodes after opening tag
    var tailValues is list<xml_value>,  // non-elements after closing tag
    var uri is string,              // namespace uri
    var xmlns is list<xmlns_declaration>
}

xmlElement' name uri attr 
        is string -> string -> hash<string, string> ->  xml_element =
   (if name == '' then
        failWith "Element must have a name"
    fi;
    {
        name,
        attributes = attr,
        elements = array [],
        var values = [],
        var tailValues = [],
        get text () =
            // speed hack
            var res = () as ~java.lang.StringBuilder;
            var str = '';
            for (values :: map (.tailValues) elements) do vl:
                for vl do v:
                    if str == '' then
                    elif nullptr? res then
                        res := new java.lang.StringBuilder(str)
                    else
                        _ = res#append(str unsafely_as ~String)
                    fi;
                    str := case v of
                           PCData s: s; 
                           CData  s: s;
                           _: "";
                           esac;
                done
            done;
            if nullptr? res then str else "\(res#append(str))" fi,
        set text str =
            for elements do element:
                element.tailValues := []
            done;
            values := [PCData str],
        var uri = uri,
        var xmlns = []
    });

xmlElement name = xmlElement' name undef_str [:];

add_value e v =
   (l = e.elements;
    if empty? l then
        e.values := v :: e.values
    else
        e = l.[length l - 1];
        e.tailValues := v :: e.tailValues
    fi);

xmlParse source =
   (var r = () as ~XMLStreamReader;
    var keepWS = false;
    var keepNS = false;
    f = XMLInputFactory#newFactory();
    for source
       \case of
        InputStream s:
            r := f#createXMLStreamReader(s is ~java.io.InputStream, 'UTF-8');
        Reader ir:
            r := f#createXMLStreamReader(ir is ~java.io.Reader);
        Source s:
            r := f#createXMLStreamReader(s is ~javax.xml.transform.Source);
        Str s:
            r := f#createXMLStreamReader(new java.io.StringReader(s));
        File fn:
            r := f#createXMLStreamReader(new java.io.FileInputStream(
                    fn is string unsafely_as ~String), 'UTF-8');
        /// Turns on/off namespace processing for XML 1.0 support.
        NSAware flag:
            f#setProperty(XMLInputFactory#IS_NAMESPACE_AWARE, flag is boolean);
        /// Turns on implementation specific DTD validation.
        Validate ():
            f#setProperty(XMLInputFactory#IS_VALIDATING, true);
        /// Requires the processor to coalesce adjacent character data.
        /// Coalescing can eat CDATA living between PCDATA.
        Coalescing flag:
            f#setProperty(XMLInputFactory#IS_COALESCING, flag is boolean);
        KeepNS ():
            keepNS := true;
        KeepWS ():
            keepWS := true;
        KeepAll ():
            keepNS := true;
            keepWS := true;
        esac;
    if nullptr? r then
        failWith "No input source given"
    fi;
    root = xmlElement 'UTF-8';
    var current = root;
    stack = array [];
    r#hasNext() loop
       (cur = current;
        case r#next() of
        XMLStreamConstants#START_ELEMENT:
            var i = r#getAttributeCount();
            attr = new yeti.lang.Hash(i) unsafely_as hash<string, string>;
            (i := i - 1; i >= 0) loop
               (qn = r#getAttributeName(i);
                attr.[if keepNS and qn#getNamespaceURI() != '' then
                         "{\(qn#getNamespaceURI())}\(qn#getLocalPart())"
                      else
                         qn#getLocalPart()
                      fi] := r#getAttributeValue(i));
            push stack cur;
            current := xmlElement' r#getLocalName() r#getNamespaceURI() attr;
            push cur.elements current;
            i := r#getNamespaceCount();
            (i := i - 1; i >= 0) loop
                current.xmlns := {
                    prefix = r#getNamespacePrefix(i),
                    uri = r#getNamespaceURI(i)
                } :: current.xmlns;
        XMLStreamConstants#END_ELEMENT:
            cur.values := reverse cur.values;
            for cur.elements do e:
                e.tailValues := reverse e.tailValues
            done;
            current := pop stack;
        XMLStreamConstants#CDATA:
            add_value cur (CData r#getText());
        XMLStreamConstants#COMMENT:
            add_value cur (Comment r#getText());
        XMLStreamConstants#DTD:
            add_value cur (DTD r#getText());
        _:
            if r#hasText() and (not r#isWhiteSpace() or keepWS) then
                add_value cur (PCData r#getText())
            fi
        esac);
    r#close();
    if empty? root.elements then
        failWith "No document element"
    fi;
    current := root.elements.[0];
    current.tailValues := root.values;
    current);

write_values w values is ~XMLStreamWriter -> list<xml_value> -> () =
    for values
       \case of
        PCData  str: w#writeCharacters(str);
        CData   str: w#writeCData(str);
        Comment str: w#writeComment(str);
        _: ();
        esac;

write_attr w e is ~XMLStreamWriter -> xml_element -> () =
   (for e.xmlns do ns:
        w#writeNamespace(ns.prefix, ns.uri)
    done;
    var i = (e.attributes unsafely_as ~java.util.Map)#entrySet()#iterator();
    i#hasNext() loop
       (e = i#next() unsafely_as ~java.util.Map$Entry;
        name = "\(e#getKey())";
        value = "\(e#getValue())";
        if name `strStarts?` '{' then
            local = strRightOf '}' name;
            uri = strSlice name 1 (strLength name - strLength local - 1);
            w#writeAttribute('xml', uri, local, value)
        else
            w#writeAttribute(name, value)
        fi));

xmlWrite to root is 'a -> xml_element -> () =
   (f = XMLOutputFactory#newInstance();
    var indent = undef_str;
    var w = () as ~XMLStreamWriter;
    var buf = () as ~java.io.StringWriter;
    var cb = \();
    for to
       \case of
        OutputStream os:
            w := f#createXMLStreamWriter(os is ~java.io.OutputStream, 'UTF-8');
        Writer ow:
            w := f#createXMLStreamWriter(ow is ~java.io.Writer);
        File fn:
            w := f#createXMLStreamWriter(new java.io.FileOutputStream(
                    fn is string unsafely_as ~String), 'UTF-8');
        Result res:
            w := f#createXMLStreamWriter(res is ~javax.xml.transform.Result);
        Out callback:
            cb := callback;
            buf := new java.io.StringWriter();
            w := f#createXMLStreamWriter(buf);
        Indent indent_str:
            indent := indent_str;
        esac;
    w = w;
    indent = indent;
    w#writeStartDocument();
    for root.tailValues
       \case of
        DTD dtd:
            if dtd != '' then
                w#writeDTD(dtd)
            fi;
        Comment str:
            w#writeComment(str);
        _: ()
        esac;
    w#setPrefix("xml", "http://www.w3.org/XML/1998/namespace");
    iter cur_indent element =
       (new_indent =
            if defined? indent then
                w#writeCharacters(cur_indent);
                cur_indent ^ indent
            else
                ""
            fi;
        for element.xmlns do ns:
            if defined? ns.prefix then
                println "setPrefix('\(ns.prefix)', '\(ns.uri)')";
                w#setPrefix(ns.prefix, ns.uri)
            else
                w#setDefaultNamespace(ns.uri)
            fi
        done;
        uri = element.uri;
        if empty? element.elements and empty? element.values then
            if defined? uri then
                w#writeEmptyElement(uri,
                    element.name is string unsafely_as ~String)
            else
                w#writeEmptyElement(element.name unsafely_as ~String)
            fi;
            write_attr w element
        else
            if defined? uri then
                w#writeStartElement(uri, element.name unsafely_as ~String)
            else
                w#writeStartElement(element.name unsafely_as ~String)
            fi;
            write_attr w element;
            write_values w element.values;
            elements = element.elements;
            for elements do e:
                iter new_indent e
            done;
            if defined? indent and not empty? elements then
                w#writeCharacters(cur_indent)
            fi;
            w#writeEndElement();
        fi;
        if not same? element root then
            write_values w element.tailValues
        fi);
    iter "\n" root;
    w#writeEndDocument();
    w#flush();
    if not nullptr? buf then
        cb "\(buf)"
    fi);

xmlByPath element path =
   (var elem = [element];
    for path do name:
        result = array [];
        for elem do ee:
            for ee.elements do e:
                if e.name == name then
                    push result e
                fi
            done
        done;
        elem := list result
    done;
    elem);

{ xmlElement, xmlParse, xmlWrite, xmlByPath }
//println (xmlParse [File '../build.xml', SkipWS ()]);
