module json;

import yeti.lang.Core;

typedef json_value'<json> = 
    Null () | Boolean boolean | Number number |
    String string | List list<json_value'> | Object hash<string, json>

typedef json = {
    str is string,
    list is list<json>,
    obj is hash<string, json>,
    num  is number,
    bool is boolean,
    value is json_value'<json>
}

typedef json_value = json_value'<json>

json value is json_value -> json = {
    get value () = value,
    get str () =
        case value of
        String s: s;
        ...
        esac,
    get obj () =
        case value of
        Object m: m;
        ...
        esac,
    get list () =
        case value of
        List l: map json l; // lazy mapping
        ...
        esac,
    get num () =
        case value of
        Number n: n;
        ...
        esac,
    get bool () =
        case value of
        Boolean v: v;
        ...
        esac,
};

json_str  = json . String;
json_num  = json . Number;
json_bool = json . Boolean;
json_list' = json . List;
json_list = json_list' . map (.value);
json_obj  = json . Object;
json_null = json (Null ());

json_decode str is string -> json =
   (invalid = failWith . ("Invalid JSON: " ^);
    var tokens = matchAll ('\s+|([{:,}\[\]]|"(?:[^\\"]|\["\\/bfnrtu])*"|' ^
                          '-?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?|null|true|false)')
                          (`at` 0) invalid str;
    println tokens;
    fetch () =
        case tokens of
        s :: rest:
            tokens := rest;
            case s of
            '': fetch ();
            '{':
                m = [:];
                empty? tokens or head tokens != '}' loop
                   (key = case fetch () of
                          String key: key;
                          v: failWith "Invalid JSON field name (\(v))";
                          esac;
                    case tokens of
                    ':' :: r: tokens := r;
                    _: failWith "JSON expecting : after object field name";
                    esac;
                    m[key] := json (fetch ());
                    case head tokens of
                    ',': tokens := tail tokens;
                    '}': ();
                    x: invalid x;
                    esac);
                tokens := tail tokens;
                Object m;
            '[':
                a = array [];
                empty? tokens or head tokens != ']' loop
                    (push a (fetch ());
                     case head tokens of
                     ',': tokens := tail tokens;
                     ']': ();
                     x: invalid x;
                     esac);
                tokens := tail tokens;
                List (list a);
            'true' : Boolean true;
            'false': Boolean false;
            'null' : Null ();
            _:  if strStarts? s '"' then
                    escape m =
                        case m[1] of
                        'n': "\n";
                        't': "\t";
                        'r': "\r";
                        'b': "\b";
                        'f': "\f";
                        s : if strLength s <= 1 then
                                s
                            else
                                x = new int[1];
                                x[0] := Integer#parseInt(strRight s 1, 16);
                                new String(x, 0, 1) unsafely_as string
                            fi
                        esac;
                    matchAll '\\(["\\/bfnrt]|u[0-9a-fA-F]{4})' escape id
                        (strSlice s 1 (strLength s - 1)) |> strJoin '' |> String
                else
                    Number (number s)
                fi
            esac;
        _: failWith "Unexpected end of JSON data"
        esac;
    res = fetch ();
    if not empty? tokens then
        failWith "Garbage after JSON data (\(head tokens))"
    fi;
    json res);

json_encode is json_value -> string =
   \case of
    String s: Core#show(s);
    Number n: "\(n)";
    Object m: "{\(mapHash (_ k v = "\(Core#show(k)):\(json_encode v.value)") m
                    |> strJoin ',')}";
    List l: "[\(map json_encode l |> strJoin ',')]";
    Boolean b: "\(b)";
    Null (): "null";
    esac;

json_encode is json -> string = json_encode . (.value);

{ json, json_str, json_num, json_bool, json_list', json_list, json_obj,
  json_null, json_decode, json_encode }
