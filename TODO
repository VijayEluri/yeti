  Yeti TODO.
~~~~~~~~~~~~~~~~~

* Better error messages
  + Module type not fully defined message is confusing,
    should give more info about where error is.
* Fix full path script invocation (yeti /some/fubar/script.yeti)
  + Use unique path identifiers (File? URL?) on module (re)compilation.
  + Better error message on: echo 'module x; ()' > y.yeti; yeti -e 'load y'
    (Cannot contain module x isn't very obvious).
    The parser should also store the line of module/program declaration.
  + When load is done verify:
      1. The module requested by load and actual file read has the same case.
         Error if the end of canonical name differs only by case.
      2. The module requested is actually same as loaded
         (since foo.yeti loaded may have wrong package). Case insensitive.
  + Allow absolute path to be URI for custom loaders.
  + Make the compileAll to use readSourceFile for Java sources.
* Rebuild modified dependencies when compiling
  + In this case doc index should still include all module names.
* Avoid upper/lowercase dups on generated classes
* Use static methods returning module fields instead of multiple
  different ways for access to have better backward compatibility
* v1.0
* Typedefs in REPL
* Foreign structs (java dto -> struct?)
* Operator to copy mutable structure fields between two different structures
* Compile modules required by load directly after parse, before type analyse
* Support as in type definitions for recursive types
* Support module qualification on type, like x is foo.sometype
* Dependency analyses on struct field self-bindings?
  (could be done by binding only free typevars first and
   unifing those with actual function field types later)
* Reuse local JVM variables (have a free var list on Ctx and add variable
  to it after last use when it could be nulled). This could compact code
  and help GC with bindings that are not explicitly nulled (type != MAP).
* Context-specific int optimizations for builtins
  (and java method invocation return values)
* Struct mapping (as in doc/stmap.yeti)
* Allow cons pattern match (::) on arrays?
* Exhaustive list match detection probably could be improved by something
  like introducing FL_EMPTY_PATTERN and keeping account about the list tail
  being exhaustive.
* Review the Java<->Yeti type autoconversions?
* Immutable tree map support - this seems to be popular feature. ;)
* Optional Java generics support?
* Direct struct-ref optimisation, when only known structs are accessed
