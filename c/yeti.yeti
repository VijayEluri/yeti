program yeti.lang.compiler.yeti;

import java.lang.ClassLoader;

var target = "";
var eval = false;
var flags = 0;
var exec = true;
var printType = false;
var src = "";

srcs = array [];
argv = array _argv;

evaluator = load yeti.lang.compiler.repl argv;

printMessage ex is ~Exception -> () =
    println ex#getMessage();

repl () =
   (print "> ";
    line = readln ();
    if defined? line then
        print (evaluator.evaluate line flags);
        repl ()
    else
        println "";
        sysExit 0
    fi);

startRepl () =
   (println "Yeti REPL.\n";
    oldEval = YetiEval#set(new YetiEval());
    try
        repl ()
    finally
        _ = YetiEval#set(oldEval)
    yrt);

help () =
   (println "yeti -flags... files\n\n\
      "  -h               Print this help\n\
      "  -C               Compile to classes\n\
      "  -e expr          Evaluate expr and print result\n\
      "  -d directory     Store generated files in the given directory\n\
      "                   (implies compile to classes)\n\
      "  -cp path         Give classpath\n\
      "  -preload modules Preload modules (: separated list)\n\
      "  -type            Print type signature of given expression or module\n";
    sysExit 0);

options = [
    "-C": \(exec := false),
    "-d": do:
        target := shift argv;
        if target != "" then
            target := "\(target)/"
        fi;
        exec := false
    done,
    "-e": \(eval := true; src := shift argv),
    "-h": help,
    "-cp": \(evaluator.classPath := shift argv),
    "-help": help,
    "-preload": \(evaluator.preload := asList (strSplit ':' (shift argv))),
    "-type": \(printType := true; exec := false),
    "-parse-tree": \(flags := flags + YetiC#CF_PRINT_PARSE_TREE),
    "-no-import": \(flags := flags + YetiC#CF_NO_IMPORT),
    "-guard": \(runDaemonThread (number (shift argv)) do time:
        sleep time;
        println "(terminated)";
        sysExit 13;
    done),
    "-safe-eval":
        \(evaluator.sandbox := true; eval := true; src := shift argv),
    "-icast": \(evaluator.gcj := true),
];

not (eval or empty? argv) and (not exec or empty? srcs) loop
   (arg = shift argv;
    if arg in options then
        try 
            options.[arg] ()
        catch EmptyArray:
            println "Parameter expected after \(arg)";
            sysExit 1
        yrt
    elif arg =~ '^-' then
        println "Unexpected option: \(arg)";
        sysExit 1;
    else
        push srcs arg
    fi);

if empty? srcs and src == "" then
    if exec and empty? argv then
        startRepl ()
    fi;
    sysExit 0
fi;

writer =
    if exec then
        new Loader()
    else
        new ToFile(target)
    fi;

compilation = evaluator.compilationOf writer;
var resultType = YetiType#UNIT_TYPE;

try
    if eval then
        flags := flags + YetiC#CF_EVAL;
        resultType := compilation#compile((), evaluator.mainClass, src, flags);
        if printType then
            println resultType
        else
            compilation#write()
        fi
    elif printType then
        YetiCode#currentCompileCtx#set(compilation);
        for srcs do src:
            println YetiTypeVisitor#getType((), src)
        done
    else
        for srcs do src:
            evaluator.mainClass := compilation#compile(src, flags)
        done;
        compilation#write()
    fi;
    compilation#enumWarns(printMessage)
catch CompileException ex:
    compilation#enumWarns(printMessage);
    printMessage ex;
    sysExit 1;
yrt;

out = if evaluator.sandbox then System#out else System#err fi;

if exec then
    try
        v = evaluator.execClass eval
                                (writer as ~Object unsafely_as ~ClassLoader);
        if resultType#deref()#type != YetiType#UNIT then
            println v
        fi
    catch java.lang.StackOverflowError ex:
        out#println("Stack overflow");
    catch java.lang.OutOfMemoryError ex:
        out#println("Out of memory");
    catch Exception ex:
        ex#printStackTrace(out);
        sysExit 2;
    yrt
fi
