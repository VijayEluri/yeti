/**
 * Yeti compiler main program.
 * Copyright (c) 2008.2009 Madis Janson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
program yeti.lang.compiler.yeti;

import java.io.File;
load yeti.lang.compiler.eval;
load yeti.lang.compiler.showtype;

var eval = undef_str;
var exec = true;
var compileErrorTrace = false;
var types = array [];
var printType = false;
var sandbox = false;
var out = System#err;
var doc_dir = undef_str;
var doc_script = '';

srcs = array [];
argv = array _argv;

options = array [];
evalOptions = array [Exec argv];
compileOptions = array [];

printMessage ex is ~CompileException -> () =
    println ex#getMessage();

repl eval =
   (print "> ";
    line = readln ();
    if defined? line then
        print (eval line).str;
        repl eval
    else
        println ""
    fi);

help =
    "yeti -flags... files\n\n\
    "  -h               Print this help\n\
    "  -e expr          Evaluate expr and print result\n\
    "  -d directory     Compile and store the generated class files\n\
    "                   in the given directory\n\
    "  -cp path         Give classpath\n\
    "  -preload modules Preload modules (: separated list)\n\
    "  -icast           Generate superfluous casts for broken JVMs\n\
    "  -javaver version Forces specified Java version when compiling Java\n\
    "  -j option        Option for Javac (used when compiling Java sources)\n\
    "  -type            Print type signature of given expression or module\n";

splitPath = strSplit File#pathSeparator;

not (defined? eval or empty? argv) and (not exec or empty? srcs) loop
   (arg = shift argv;
    if arg `strStarts?` '-' then
        case arg of
        "-C":
            push options (To '');
            exec := false;
        "-d":
            target = shift argv;
            push options (To target);
            exec := false;
        "-e":
            eval := shift argv;
        "-cp":
            push options (ClassPath (splitPath (shift argv)));
        "-preload":
            push options (Preload (splitPath (shift argv)));
        "-type":
            printType := true;
            exec := false;
            push compileOptions (Type (push types));
        "-doc":
            doc_dir := shift argv;
            exec := false;
            push compileOptions (Type (push types));
        "-doc-format":
            doc_script := shift argv;
        "-javaver":
            ver = shift argv;
            for ['-source', ver, '-target', ver]
                (push compileOptions . JavaOption);
        "-j":
            push compileOptions (JavaOption (shift argv));
        "-guard":
            time = number (shift argv);
            _ = runThread [Daemon ()] do:
                sleep time;
                println "(terminated)";
                System#exit(13)
            done;
        "-safe-eval":
            push evalOptions (GlobalSandbox ());
            sandbox := true;
            eval := shift argv;
            out := System#out;
        "-compile-error-trace":
            compileErrorTrace := true;
        "-icast":
            push options (ICast ());
        "-parse-tree":
            push options (ParseTree ());
        "-no-import":
            push options (NoImport ());
        "-no-frames":
            push options (NoFrames ());
        "-v":
            println "Yeti \(yetiRuntimeVersion)";
            sysExit 0;
        _:
            case arg of
            "-h": ();
            "-help": ();
            "--help": ();
            _:
                println "Unexpected option: \(arg)";
                sysExit 1;
            esac;
            println help;
            sysExit 0
        esac
    else
        push srcs arg
    fi);

scan src local dirs to =
   (var ok = true;
    if src `strEnds?` '.yeti' then
        name = if local == '' then src else local fi;
        // avoid duplicates, prefer shortest name
        if not src in to or strLength to.[src] > strLength name then
            to.[src] := name
        fi
    elif src `strEnds?` '.java' then
        to.[src] := src // javac prefers full path
    else
        dirList = listDirectory false src;
        ok := not empty? dirList or new File(src)#isDirectory();
        if ok then
            dirs src;
        fi;
        for dirList do {name, path}:
            fn = if local == '' then name else "\(local)/\(name)" fi;
            _ = scan path fn \() to
        done
    fi;
    ok);

printException ex is ~java.lang.Throwable -> () =
   (if sandbox and ex instanceof java.lang.StackOverflowError then
        out#println("Stack overflow")
    elif ex instanceof java.lang.OutOfMemoryError then
        out#println("Out of memory")
    else
        ex#printStackTrace(out)
    fi;
    sysExit 2);

push options (Warn printMessage);

if defined? eval then
    if printType then
        push evalOptions (NoExec ());
    fi;
    {type, result} = evaluateYetiCode options evalOptions eval;
    case result of
    Exception ex:
        printException ex;
    CompileException ex:
        printMessage ex;
        sysExit 1;
    Result val: 
        if printType then
            println (showType [] '' type)
        elif exec and type != Simple "()" then
            println val
        fi
    esac
elif empty? srcs then
    if exec and empty? argv then
        _ = pop options; // no Warn
        println "Yeti \(yetiRuntimeVersion) REPL.\n";
        push evalOptions (Bind ());
        repl (evaluateYetiCode options evalOptions)
    fi
else
    if exec then
        push compileOptions (Exec argv)
    fi;
    files = [:];
    sourcePath = array [];
    for srcs do src:
        if not scan src '' (push sourcePath) files then
            println "Don't know what to do with `\(src)'";
            sysExit 1
        fi
    done;
    try
        compileYetiFiles options compileOptions (list files);
    catch CompileException ex:
        if compileErrorTrace then
            ex#printStackTrace()
        fi;
        printMessage ex;
        sysExit 1
    catch java.lang.reflect.InvocationTargetException ex:
        printException ex#getCause()
    catch java.lang.Throwable ex:
        printException ex
    yrt;
    if not empty? types then
        if defined? doc_dir then
            generateYetiDoc {directory = doc_dir, types, error = println}
        else
            for types do t:
                if t.doc != "" then
                    println "/*\n\(t.doc)\n*/"
                fi;
                println "module \(t.name);\n";
                for t.typedefs do {name, type, param}:
                    p = if not empty? param then "<\(strJoin ', ' param)>" fi;
                    println "typedef \(name)\(p) = \
                            "\(showType [CommentDoc ()] '' type)\n"
                done;
                println (showType [CommentDoc ()] '' t.type);
            done
        fi
    fi
fi
