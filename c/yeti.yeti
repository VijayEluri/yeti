program yeti.lang.compiler.yeti;

import java.lang.Class;
import yeti.lang.Core;

var target = "";
var eval = false;
var exec = true;
var printType = false;
var preload = ["yeti/lang/std", "yeti/lang/io"];
var src = "";
var mainClass = "code";
var flags = 0;

srcs = array [];
argv = array _argv;

compilationOf writer =
    new YetiCode$CompileCtx(new YetiC(), writer, preload, new ClassFinder(""));

execClass writer =
   (c = Class#forName(replace '/' '.' mainClass, true,
                      writer unsafely_as ~java.lang.ClassLoader);
    try
        if eval then
            (c#newInstance() unsafely_as () -> '') ()
        else
            c#getMethod("main", [Class#forName('[Ljava.lang.String;')])
             #invoke((), [argv as ~java.lang.String[]])
        fi
    catch java.lang.reflect.InvocationTargetException ex:
        t = ex#getCause();
        throw if defined? t then t else ex fi;
    yrt);

repl () =
   (print "> ";
    line = readln ();
    if defined? line then
        writer = new Loader();
        try
            bindings = YetiEval#get()#bindings;
            bindBarrier = bindings#size();
            compilation = compilationOf (writer as ~CodeWriter);
            type = compilation#compile((), mainClass, line, flags);
            compilation#write();
            try
                res = execClass writer;
                if type#deref()#type != YetiType#UNIT then
                    println "\(Core#show(res)) is \(type)"
                fi
            catch Exception ex:
                ex#printStackTrace()
            catch java.lang.StackOverflowError ex:
                ex#printStackTrace()
            yrt;
            for [bindBarrier .. bindings#size() - 1] do i:
                binding = bindings#get(i) unsafely_as ~YetiEval$Binding;
                println "\(if binding#mutable then "var " else "" fi)\
                        "\(binding#name) is \(binding#type) = \(binding#val())";
            done
        catch CompileException ex:
            println ex#getMessage()
        yrt;
        repl ()
    else
        println "";
        sysExit 0
    fi);

startRepl () =
   (println "Yeti REPL.\n";
    eval := true;
    flags := YetiC#CF_EVAL + YetiC#CF_EVAL_BIND;
    oldEval = YetiEval#set(new YetiEval());
    try
        repl ()
    finally
        ignore YetiEval#set(oldEval)
    yrt);

help () =
   (println "yeti -flags... files\n\n\
      "  -h               Print this help\n\
      "  -C               Compile to classes\n\
      "  -e expr          Evaluate expr and print result\n\
      "  -d directory     Store generated files in the given directory\n\
      "                   (implies compile to classes)\n\
      "  -preload modules Preload modules (: separated list)\n\
      "  -type            Print type signature of given expression or module\n";
    sysExit 0);

if empty? argv then
    startRepl ()
fi;

options = [
    "-C": \(exec := false),
    "-d": do:
        target := shift argv;
        if target != "" then
            target := "\(target)/"
        fi;
        exec := false
    done,
    "-e": \(eval := true; src := shift argv),
    "-h": help,
    "-help": help,
    "-preload": \(preload := split ':' (shift argv)),
    "-type": \(printType := true; exec := false),
    "-parse-tree": \(flags := flags + YetiC#CF_PRINT_PARSE_TREE),
];

not (eval or empty? argv) and (not exec or empty? srcs) loop
   (arg = shift argv;
    if arg in options then
        try 
            options.[arg] ()
        catch EmptyArray:
            println "Parameter expected after \(arg)";
            sysExit 1
        yrt
    elif arg =~ '^-' then
        println "Unexpected option: \(arg)";
        sysExit 1;
    else
        push srcs arg
    fi);

if empty? srcs and src == "" then
    sysExit 0
fi;

writer =
    if exec then
        new Loader()
    else
        new ToFile(target)
    fi;

compilation = compilationOf writer;
var resultType = YetiType#UNIT_TYPE;

try
    if eval then
        flags := flags + YetiC#CF_EVAL;
        resultType := compilation#compile((), mainClass, src, flags);
        if printType then
            println resultType
        else
            compilation#write()
        fi
    elif printType then
        for srcs do src:
            println YetiTypeVisitor#getType((), src)
        done
    else
        for srcs do src:
            mainClass := compilation#compile(src, flags)
        done;
        compilation#write()
    fi
catch CompileException ex:
    println ex#getMessage();
    sysExit 1;
yrt;

if exec then
    try
        v = execClass writer;
        if resultType#deref()#type != YetiType#UNIT then
            println v
        fi
    catch Exception ex:
        ex#printStackTrace();
        sysExit 2;
    yrt
fi
