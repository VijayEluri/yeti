/**
 * Yeti compiler and eval (derived from old REPL module) interface.
 * Copyright (c) 2008,2009,2011 Madis Janson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
module yeti.lang.compiler.eval;

import java.lang: Class, ClassLoader, Thread, Throwable;
import yeti.lang.Core;
import java.security.Permission;
import java.io.File;

load yeti.lang.compiler.showtype;

initSandbox () =
   (var sandboxed = \();
    class Sandbox extends java.lang.SecurityManager
        void checkPermission(Permission perm)
            sandboxed (),
        void checkPermission(Permission perm, Object context)
            sandboxed (),
        void checkExit(int status)
            ()
    end;
    System#setSecurityManager(new Sandbox());
    // can't activate before, because
    // setSecurityManager would fail otherwise
    sandboxed := \throw new java.lang.SecurityException());

// XXX: Beware - the GlobalSandbox argument sets a very restricive
//      security manager globally and you CANNOT remove it later.
execClass params eval loader mainClass
        is 'a -> boolean -> ~ClassLoader -> string -> ~Object =
   (var argv = array [] is array<string>;
    var sandbox = false;
    var exec = true;
    for params do param:
        case param of
        Argument arg: argv := arg;
        GlobalSandbox _: sandbox := true;
        NoExec _: exec := false;
        ResetEnv _: ();
        esac
    done;
    if exec then
        c = Class#forName(strReplace '/' '.' mainClass, true, loader);
        old_argv = Core#ARGV#get();
        try
            if eval then
                Core#ARGV#set(argv);
                f = c#newInstance() unsafely_as () -> 'a;
                if sandbox then
                    initSandbox ();
                fi;
                f ()
            else
                aa = new Object[1];
                aa.[0] := argv is array<string> as ~String[] as ~Object;
                c#getMethod("main", [classOf String[]])#invoke((), aa)
            fi
        catch java.lang.reflect.InvocationTargetException ex:
            t = ex#getCause();
            throw if defined? t then t else ex fi;
        finally
            Core#ARGV#set(old_argv)
        yrt
    fi);

// XXX its still experimental
evalContext = do:
    var flags = 0;
    var gcj = false;
    var noframes = false;
    reader = new YetiC();

    {
        var preload = ["yeti/lang/std", "yeti/lang/io"],
        var mainClass = "code",
        var classPath = [],

        option opt =
            case opt of
            "-parse-tree": flags := flags + YetiC#CF_PRINT_PARSE_TREE;
            "-no-import" : flags := flags + YetiC#CF_NO_IMPORT;
            "-no-frames" : noframes := true;
            "-icast"     : gcj := true;
            ...
            esac,

        compilationOf writer is ~CodeWriter -> ~CompileCtx =
            ctx = new CompileCtx(reader, writer,
                        preload is list?<string> as ~String[],
                        new ClassFinder(classPath is list?<string>));
            if gcj then
                ctx#isGCJ := true
            fi;
            if noframes then
                ctx#classWriterFlags := 0
            fi;
            ctx,

        compileString {source is string,
                       writer is ~CodeWriter,
                       warnings is array<~CompileException>,
                       extraFlags is number} =
            compilation = compilationOf writer;
            type =
                try
                    compilation#compile((), mainClass, source,
                                        flags + extraFlags);
                finally
                    compilation#enumWarns(push warnings)
                yrt;
            TypeDescr#yetiType(type) unsafely_as type,

        compileFiles {sourcePath is list?<string>,
                      files is list?<string>,
                      writer is ~CodeWriter,
                      warn is ~CompileException -> (),
                      javaOptions is list?<string>} =
            compilation = compilationOf writer;
            reader#basedirs := sourcePath as ~String[];
            try
                mainClass :=
                   compilation#compileAll(sort (list files), flags, javaOptions)
            finally
                compilation#enumWarns(warn)
            yrt,
    }
done;

compileYetiFiles options files =
   (var writer = () as ~CodeWriter;
    var exec = false;
    var execArg = array [];
    var typeAction = None ();
    var warn = \();
    sourcePath = array [];
    javaOptions = array [];
    evaluator = evalContext ();
    for options do opt:
        case opt of
        Type action:
            typeAction := Some action;
        Warn action:
            warn := action;
        Exec arg:
            exec := true;
            execArg := arg;
        To dir:
            if not defined? writer then
                push javaOptions '-d';
                push javaOptions dir;
            fi;
            writer := new ToFile(dir) as ~CodeWriter;
        SourceDir dir:
            push sourcePath dir;
        JavaOption option:
            push javaOptions option;
        esac
    done;
    if not defined? writer then
        writer := new Loader() as ~CodeWriter;
    elif exec then
        failWith "To andExec options together are not supported"
    fi;
    case typeAction of
    Some action:
        if exec then
            failWith "Exec with Type is not implemented yet"
        fi;
        if writer instanceof ToFile then
            failWith "To with Type is not implemented yet"
        fi;
        old_ctx = CompileCtx#currentCompileCtx#get();
        CompileCtx#currentCompileCtx#set(evaluator.compilationOf writer);
        try
            for files do src:
                mt = YetiTypeVisitor#getType((), src, true);
                action {type = TypeDescr#yetiType(mt#type) unsafely_as type,
                        doc = mt#topDoc};
            done;
        finally
            CompileCtx#currentCompileCtx#set(old_ctx)
        yrt;
    _:
        evaluator.compileFiles {sourcePath, writer,
                                javaOptions, files, warn}
    esac;
    if exec then
        try
            classLoader = writer as ~Object unsafely_as ~ClassLoader;
            Thread#currentThread()#setContextClassLoader(classLoader);
            _ = execClass [Argument execArg] false classLoader
                          evaluator.mainClass;
        catch java.lang.OutOfMemoryError ex:
            throw ex
        catch java.lang.ThreadDeath ex:
            throw ex // honor thread death also
        catch Throwable th:
            throw new java.lang.reflect.InvocationTargetException(th)
        yrt
    fi);

evaluateYetiCode () =
   (var flags = YetiC#CF_EVAL + YetiC#CF_EVAL_BIND;
    var evalEnv = () as ~YetiEval;
    mainClass = "code";
    do options code:
        bindingVars = array [];
        warnings = array [];
        var type = Simple '()';
        writer = new Loader();

        oldContext = YetiEval#get();
        if not defined? evalEnv or contains (ResetEnv ()) options then
            evalEnv := new YetiEval()
        fi;
        YetiEval#set(evalEnv);

        result =
            try
                bindings = YetiEval#get()#bindings;
                var bindBarrier = bindings#size();
                compilation = (evalContext ()).compilationOf writer;
                try
                    t = compilation#compile((), mainClass,
                                            code is string, flags);
                    type := TypeDescr#yetiType(t) unsafely_as type
                finally
                    compilation#enumWarns(push warnings)
                yrt;
                val =
                    try
                        Result (execClass options true writer mainClass);
                    catch java.lang.StackOverflowError ex:
                        Exception (ex as ~Throwable)
                    catch java.lang.VirtualMachineError ex:
                        // other virtualmachine errors will be rethrown
                        // (including OutOfMemoryError)
                        throw ex
                    catch java.lang.ThreadDeath ex:
                        throw ex // honor thread death also
                    catch Throwable ex:
                        Exception ex
                    yrt;

                bindBarrier < bindings#size() loop
                   (push bindingVars (bindings#get(bindBarrier)
                                        unsafely_as ~YetiEval$Binding);
                    bindBarrier := bindBarrier + 1);
                val
            catch CompileException ex:
                CompileException ex
            finally
                YetiEval#set(oldContext)
            yrt;

        bindings () =
           (res = array [];
            for bindingVars do binding:
                if not binding#isImport then
                    t = binding#type;
                    push res "\(if binding#mutable then "var " else "" fi)\
                             "\(binding#name) is \(t) = \
                             "\(if t#deref()#type == YetiType#UNIT then
                                    "()"
                                elif nullptr? binding#value then
                                    "<undef>"
                                else
                                    Core#show(binding#val())
                                fi)"
                fi
            done;
            res);

        {
            warnings, type, result,
        
            get bindings () = list (bindings ()),

            get str () =
                res = bindings ();
                case result of
                Exception ex:
                    push res (stackTraceString ex);
                CompileException ex:
                    push res (ex is ~CompileException)#getMessage();
                Result val:
                    if type != Simple "()" then
                        push res
                             "\(Core#show(val)) is \(showType [] '' type)"
                    fi
                esac;
                strJoin '' (map (^ "\n") res),
        }
    done);

{
    evalContext, execClass,

    compileYetiFiles, evaluateYetiCode

    // needs context.
    // evaluate options source

    // context could be useful
    // getType options (Code s | File s)
    // although evaluate fills the (Code s) case anyway.
    // it would be nice to reduce it all to evaluate and compileFiles.

    // compileFiles options
    // execFiles options
    // could be joined, if Exec were option?

    // there could be target option(s) also.
    // Type (type-action)
    // Exec argument
    // To dir
    // --- yes, seems that evaluate () options source
    //                 and compileFiles options files would be okey.
}
