/**
 * Yeti compiler and eval (derived from old REPL module) interface.
 * Copyright (c) 2008,2009,2011 Madis Janson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
module yeti.lang.compiler.eval;

import java.lang: Class, ClassLoader, Thread, Throwable;
import yeti.lang.Core;
import java.security.Permission;
import java.io.File;

load yeti.lang.compiler.showtype;

// XXX: Beware - the GlobalSandbox argument sets a very restricive
//      security manager globally and you CANNOT remove it later.
execClass argv sandbox eval loader mainClass
        is array<string> -> boolean -> boolean
           -> ~ClassLoader -> string -> ~Object =
   (c = Class#forName(strReplace '/' '.' mainClass, true, loader);
    old_argv = Core#ARGV#get();
    th = Thread#currentThread();
    old_cl = th#getContextClassLoader();
    th#setContextClassLoader(loader);
    try
        if eval then
            Core#ARGV#set(argv);
            f = c#newInstance() unsafely_as () -> 'a;
            if sandbox then
                var sandboxed = \();
                class Sandbox extends java.lang.SecurityManager
                    void checkPermission(Permission perm)
                        sandboxed (),
                    void checkPermission(Permission perm, Object context)
                        sandboxed (),
                    void checkExit(int status)
                        ()
                end;
                System#setSecurityManager(new Sandbox());
                // can't activate before, because
                // setSecurityManager would fail otherwise
                sandboxed := \throw new java.lang.SecurityException()
            fi;
            f ()
        else
            aa = new Object[1];
            aa.[0] := argv is array<string> as ~String[] as ~Object;
            c#getMethod("main", [classOf String[]])#invoke((), aa)
        fi
    catch java.lang.reflect.InvocationTargetException ex:
        t = ex#getCause();
        throw if defined? t then t else ex fi;
    finally
        Core#ARGV#set(old_argv);
        th#setContextClassLoader(old_cl);
    yrt);

createCtx reader writer genericOpt =
   (var warn = \() is ~CompileException -> ();
    var classPath = [] is list<string>;
    ctx = new CompileCtx(reader, writer);

    for genericOpt do opt:
        case opt of
        Warn action: warn := action;
        ClassPath path: classPath := classPath ++ path;
        ICast ():     ctx#isGCJ := true;
        Preload p:    ctx#preload := p is list?<string> as ~String[];
        ParseTree (): ctx#flags := ctx#flags b_or YetiC#CF_PRINT_PARSE_TREE;
        NoImport ():  ctx#flags := ctx#flags b_or YetiC#CF_NO_IMPORT;
        NoFrames ():  ctx#classWriterFlags := 0
        esac
    done;
    ctx#classPath := new ClassFinder(classPath);
    {warn, ctx});

compileYetiFiles genericOpt options files =
   (var exec = false;
    var execArg = array [];
    var typeAction = None ();
    var mainClass = undef_str;

    reader = new YetiC();
    {ctx, warn} = createCtx reader (() as ~CodeWriter) genericOpt;

    sourcePath = array [];
    javaOptions = array [];
    for options do opt:
        case opt of
        Type action:
            typeAction := Some action;
        Exec arg:
            exec := true;
            execArg := arg;
        To dir:
            if not defined? ctx#writer then
                push javaOptions '-d';
                push javaOptions dir;
            fi;
            ctx#writer := new ToFile(dir) as ~CodeWriter;
        SourceDir dir:
            push sourcePath dir;
        JavaOption option:
            push javaOptions option;
        esac
    done;
    reader#basedirs := sourcePath as ~String[];
    if not defined? ctx#writer then
        ctx#writer := new Loader() as ~CodeWriter;
    elif exec then
        failWith "To andExec options together are not supported"
    fi;
    case typeAction of
    Some action:
        if exec then
            failWith "Exec with Type is not implemented yet"
        fi;
        if ctx#writer instanceof ToFile then
            failWith "To with Type is not implemented yet"
        fi;
        CompileCtx#currentCompileCtx#set(ctx);
        for files do src:
            mt = YetiTypeVisitor#getType((), src, true);
            action {type = TypeDescr#yetiType(mt#type) unsafely_as type,
                    doc = mt#topDoc};
        done;
    _:
        try
            mainClass := ctx#compileAll(sort (list files), 0, javaOptions)
        finally
            ctx#enumWarns(warn)
        yrt
    esac;
    if exec then
        try
            classLoader = ctx#writer unsafely_as ~ClassLoader;
            _ = execClass execArg false false classLoader mainClass;
        catch java.lang.OutOfMemoryError ex:
            throw ex
        catch java.lang.ThreadDeath ex:
            throw ex // honor thread death also
        catch Throwable th:
            throw new java.lang.reflect.InvocationTargetException(th)
        yrt
    fi);

debugStupidWarning = ();

evaluateYetiCode genericOpt =
   (var evalEnv = () as ~YetiEval;
    mainClass = "code";
    do options code:
        bindingVars = array [];
        var type = Simple '()';
        var bind = true;
        var exec = true;
        var sandbox = false;
        var argv = array [];
        writer = new Loader();
        {ctx, warn} = createCtx new YetiC() writer genericOpt;
        ctx#flags := YetiC#CF_EVAL;

        for options do opt:
            case opt of
            ResetEnv (): evalEnv := new YetiEval();
            NoBind (): bind := false;
            NoExec (): exec := false;
            Exec a: argv := a;
            GlobalSandbox (): sandbox := true;
            esac;
        done;

        oldContext = YetiEval#get();
        if bind then
            ctx#flags := ctx#flags b_or YetiC#CF_EVAL_BIND
        fi;
        if not defined? evalEnv then
            evalEnv := new YetiEval()
        fi;
        YetiEval#set(evalEnv);

        result =
            try
                bindings = evalEnv#bindings;
                var bindBarrier = bindings#size();
                try
                    t = ctx#compile((), mainClass, code is string, ctx#flags);
                    type := TypeDescr#yetiType(t) unsafely_as type
                finally
                    ctx#enumWarns(warn)
                yrt;
                val =
                    if exec then
                        try
                            Result (execClass argv sandbox true
                                              writer mainClass);
                        catch java.lang.StackOverflowError ex:
                            Exception (ex as ~Throwable)
                        catch java.lang.VirtualMachineError ex:
                            // other virtualmachine errors will be rethrown
                            // (including OutOfMemoryError)
                            throw ex
                        catch java.lang.ThreadDeath ex:
                            throw ex // honor thread death also
                        catch Throwable ex:
                            Exception ex
                        yrt
                    else
                        Result (() as ~Object)
                    fi;

                bindBarrier < bindings#size() loop
                   (push bindingVars (bindings#get(bindBarrier)
                                        unsafely_as ~YetiEval$Binding);
                    bindBarrier := bindBarrier + 1);
                val
            catch CompileException ex:
                CompileException ex
            finally
                YetiEval#set(oldContext)
            yrt;

        bindings () =
           (res = array [];
            for bindingVars do binding:
                if not binding#isImport then
                    t = binding#type;
                    push res "\(if binding#mutable then "var " else "" fi)\
                             "\(binding#name) is \(t) = \
                             "\(if t#deref()#type == YetiType#UNIT then
                                    "()"
                                elif nullptr? binding#value then
                                    "<undef>"
                                else
                                    Core#show(binding#val())
                                fi)"
                fi
            done;
            res);

        {
            type, result,
        
            get bindings () = list (bindings ()),

            get str () =
                res = bindings ();
                case result of
                Exception ex:
                    push res (stackTraceString ex);
                CompileException ex:
                    push res (ex is ~CompileException)#getMessage();
                Result val:
                    if type != Simple "()" then
                        push res
                             "\(Core#show(val)) is \(showType [] '' type)"
                    fi
                esac;
                strJoin '' (map (^ "\n") res),
        }
    done);

{
    compileYetiFiles, evaluateYetiCode
}
