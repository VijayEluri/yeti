/**
 * Yeti compiler and eval (derived from old REPL module) interface.
 * Copyright (c) 2008,2009,2011 Madis Janson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
module yeti.lang.compiler.eval;

import java.lang: Class, ClassLoader, Thread, Throwable;
import yeti.lang.Core;
import java.security.Permission;
import java.io.File;

load yeti.lang.compiler.showtype;

// XXX: Beware - the GlobalSandbox argument sets a very restricive
//      security manager globally and you CANNOT remove it later.
execClass argv sandbox eval loader mainClass
        is array<string> -> boolean -> boolean
           -> ~ClassLoader -> string -> ~Object =
   (c = Class#forName(strReplace '/' '.' mainClass, true, loader);
    old_argv = Core#ARGV#get();
    th = Thread#currentThread();
    old_cl = th#getContextClassLoader();
    th#setContextClassLoader(loader);
    try
        if eval then
            Core#ARGV#set(argv);
            f = c#newInstance() unsafely_as () -> 'a;
            if sandbox then
                class Sandbox(boolean[] act) extends java.lang.SecurityManager
                    void checkPermission(Permission perm)
                        this#checkPermission(perm, ()),
                    void checkPermission(Permission perm, Object context)
                        if act.[0] then
                            throw new java.lang.SecurityException()
                        fi,
                    void checkExit(int status)
                        ()
                end;
                sandboxed = new boolean[1];
                System#setSecurityManager(new Sandbox(sandboxed));
                // can't activate before, because
                // setSecurityManager would fail otherwise
                sandboxed.[0] := true
            fi;
            f ()
        else
            aa = new Object[1];
            aa.[0] := argv is array<string> as ~String[] as ~Object;
            c#getMethod("main", [classOf String[]])#invoke((), aa)
        fi
    finally
        Core#ARGV#set(old_argv);
        th#setContextClassLoader(old_cl);
    yrt);

createCtx reader genericOpt =
   (var warn = \() is ~CompileException -> ();
    var classPath = [] is list<string>;
    ctx = new CompileCtx(reader is ~YetiC, ());
    java = array [];

    for genericOpt do opt:
        case opt of

        /// Set destination directory, where to write class files.
        /// Disables execution on evaluateYetiCode as side effect.
        To dir:
            if nullptr? ctx#writer and dir != '' then
                push java '-d';
                push java dir;
            fi;
            ctx#writer := new ToFile(dir) as ~CodeWriter;

        /// Set custom source reader function
        SourceReader f:
            reader#override :=
                f is {var .name is string, .fullpath is boolean} -> string
                  as ~yeti.lang.Fun;

        /// Set custom CodeWriter
        CodeWriter writer:
            ctx#writer := writer;

        /// Set warning handler (~CompileException -> ()).
        /// Called once for each warning.
        /// Hint: use Warn (push somewhere).
        Warn action: warn := action;

        /// Give class path to search for compiled libraries.
        ClassPath path: classPath := classPath ++ path;

        /// If you have really broken JVM, generate superfluous casts.
        ICast ():     ctx#isGCJ := true;

        /// Set modules that are preloaded. Default is yeti.lang.std and io.
        Preload p:    ctx#preload := p is list?<string> as ~String[];

        /// Print parse tree to stdout.
        /// Not very useful, unless you want to debug the compiler.
        ParseTree (): ctx#flags := ctx#flags b_or YetiC#CF_PRINT_PARSE_TREE;

        /// Disable importing foreign classes. Useful when sandboxing.
        NoImport ():  ctx#flags := ctx#flags b_or YetiC#CF_NO_IMPORT;

        /// Disable generation of Java 1.6 frames to class files (mainly useful
        /// for debugging, this option is not needed to run on older JVMs).
        NoFrames ():  ctx#classWriterFlags := 0
        esac
    done;
    ctx#classPath := new ClassFinder(classPath);
    if nullptr? ctx#writer then
        ctx#writer := new Loader() as ~CodeWriter;
    fi;
    {warn, ctx, java});

compileYetiFiles genericOpt options files =
   (var exec = false;
    var execArg = array [];
    var typeAction = () as ~yeti.lang.Fun;
    var mainClass = '';

    reader = new YetiC();
    {ctx, warn, java = javaOptions} = createCtx reader genericOpt;

    sourcePath = array [];
    for options do opt:
        case opt of

        /// Get module types. The action ({type is type, doc is string} -> ())
        /// is called after each module file given for compilation. 
        Type action:
            typeAction :=
                action is {.doc is string, .name is string, .type is type} -> ()
                       as ~yeti.lang.Fun;

        /// Execute main after compilation of the sources.
        /// The _argv will be set to the arg parameter.
        Exec arg:
            if not ctx#writer instanceof Loader then
                throw new CompileException(0, 0,
                    "To and Exec options together are not supported")
            fi;
            exec := true;
            execArg := arg;

        /// Add source directory to source path (where compiler searches
        /// for uncompiled dependencies).
        SourceDir dir:
            push sourcePath dir;

        /// Option to give to the javac,
        /// when .java files were in source file set.
        JavaOption option:
            push javaOptions option;
        esac
    done;
    reader#basedirs := sourcePath as ~String[];
    if not nullptr? typeAction and not exec
            and ctx#writer instanceof Loader then
        CompileCtx#currentCompileCtx#set(ctx);
        for files do src:
            TypeDescr#doc(YetiTypeVisitor#getType((), src, true),
                          typeAction)
        done
    else
        ctx#moduleTypeCb := typeAction;
        try
            mainClass := ctx#compileAll(sort (list files), 0, javaOptions)
        finally
            ctx#enumWarns(warn)
        yrt
    fi;
    if exec then
        classLoader = ctx#writer unsafely_as ~ClassLoader;
        // The Java reflection API used by execClass to invoke main() will
        // wrap exceptions from user code into InvocationTargetException,
        // so we don't need to do anything here with those exceptions.
        _ = execClass execArg false false classLoader mainClass;
    fi);

evaluateYetiCode genericOpt =
   (var evalEnv = () as ~YetiEval;
    mainClass = "code";
    do options code:
        bindingVars = array [];
        var type = Simple '()';
        var exec = true;
        var bind = false;
        var sandbox = false;
        var argv = array [];
        {ctx, warn} = createCtx new YetiC() genericOpt;
        ctx#flags := YetiC#CF_EVAL + YetiC#CF_EVAL_RESOLVE;

        for options do opt:
            case opt of
            /// Store top-level bindings in the evaluation environment,
            /// so they could be accessed by later evaluations with
            /// the same context..
            Bind (): bind := true;

            /// Set _argv to given parameter turing execution.
            Exec a: argv := a;

            /// Don't execute the code actually, only compile.
            /// Useful, if you just want to get the type of expression.
            NoExec (): exec := false;

            /// Create global sandbox before execution.
            /// Unfortunately, you can't disable it later.
            GlobalSandbox (): sandbox := true;
            esac;
        done;

        if bind then
            ctx#flags := ctx#flags b_or YetiC#CF_EVAL_STORE;
        fi;

        if nullptr? evalEnv then
            evalEnv := new YetiEval()
        fi;

        bindings = evalEnv#bindings;
        var bindBarrier = bindings#size();

        oldContext = YetiEval#set(evalEnv);

        result =
            try
                compileErr =
                    try
                        t = ctx#compile((), mainClass, code is string,
                                        ctx#flags);
                        type := TypeDescr#yetiType(t) unsafely_as type;
                        () as ~CompileException
                    catch CompileException ex:
                        ex
                    finally
                        ctx#enumWarns(warn)
                    yrt;
                if not nullptr? compileErr then
                    CompileException compileErr
                elif exec and ctx#writer instanceof Loader then
                    val = Result (execClass argv sandbox true
                                            (ctx#writer unsafely_as ~Loader)
                                            mainClass);
                    bindBarrier < bindings#size() loop
                       (push bindingVars (bindings#get(bindBarrier)
                                            unsafely_as ~YetiEval$Binding);
                        bindBarrier := bindBarrier + 1);
                    val
                else
                    Result (() as ~Object)
                fi
            catch java.lang.StackOverflowError ex:
                Exception (ex as ~Throwable)
            catch java.lang.VirtualMachineError ex:
                // other virtualmachine errors will be rethrown
                // (including OutOfMemoryError)
                throw ex
            catch java.lang.ThreadDeath ex:
                throw ex // honor thread death also
            catch Throwable ex:
                Exception ex
            finally
                YetiEval#set(oldContext)
            yrt;

        bindings () =
           (res = array [];
            for bindingVars do binding:
                if not binding#isImport then
                    t = binding#type;
                    push res "\(if binding#mutable then "var " else "" fi)\
                             "\(binding#name) is \(t) = \
                             "\(if t#deref()#type == YetiType#UNIT then
                                    "()"
                                elif nullptr? binding#value then
                                    "<undef>"
                                else
                                    Core#show(binding#val())
                                fi)"
                fi
            done;
            res);

        {
            type, result,
        
            get bindings () = list (bindings ()),

            get str () =
                res = bindings ();
                case result of
                Exception ex:
                    push res (stackTraceString ex);
                CompileException ex:
                    push res (ex is ~CompileException)#getMessage();
                Result val:
                    if type != Simple "()" then
                        push res
                             "\(Core#show(val)) is \(showType [] '' type)"
                    fi
                esac;
                strJoin '' (map (^ "\n") res),
        }
    done);

{
    compileYetiFiles, evaluateYetiCode
}
