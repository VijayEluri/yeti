/**
 * Yeti compiler and eval (derived from old REPL module) interface.
 * Copyright (c) 2008,2009,2011 Madis Janson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
module yeti.lang.compiler.eval;

import java.lang: Class, ClassLoader;
import yeti.lang.Core;
import java.security.Permission;
import java.io.File;

load yeti.lang.compiler.showtype;

initSandbox () =
   (var sandboxed = \();
    class Sandbox extends java.lang.SecurityManager
        void checkPermission(Permission perm)
            sandboxed (),
        void checkPermission(Permission perm, Object context)
            sandboxed (),
        void checkExit(int status)
            ()
    end;
    System#setSecurityManager(new Sandbox());
    // can't activate before, because
    // setSecurityManager would fail otherwise
    sandboxed := \throw new java.lang.SecurityException());

// XXX: Beware - the GlobalSandbox argument sets a very restricive
//      security manager globally and you CANNOT remove it later.
execClass params eval loader mainClass
        is 'a -> boolean -> ~ClassLoader -> string -> ~Object =
   (var argv = array [];
    var sandbox = false;
    var exec = true;
    for params do param:
        case param of
        Argument arg: argv := arg;
        GlobalSandbox _: sandbox := true;
        NoExec _: exec := false;
        ResetEnv _: ();
        esac
    done;
    if exec then
        c = Class#forName(strReplace '/' '.' mainClass, true, loader);
        old_argv = Core#ARGV#get();
        try
            if eval then
                Core#setArgv(argv);
                f = c#newInstance() unsafely_as () -> 'a;
                if sandbox then
                    initSandbox ();
                fi;
                f ()
            else
                aa = new Object[1];
                aa.[0] := argv is array<string> as ~String[] as ~Object;
                c#getMethod("main", [classOf String[]])#invoke((), aa)
            fi
        catch java.lang.reflect.InvocationTargetException ex:
            t = ex#getCause();
            throw if defined? t then t else ex fi;
        finally
            Core#ARGV#set(old_argv)
        yrt
    fi);

// XXX its still experimental
evalContext = do:
    var flags = 0;
    var gcj = false;
    var noframes = false;
    var evalEnv = () as ~YetiEval;
    reader = new YetiC();

    {
        var preload = ["yeti/lang/std", "yeti/lang/io"],
        var mainClass = "code",
        var classPath = [],

        option opt =
            case opt of
            "-parse-tree": flags := flags + YetiC#CF_PRINT_PARSE_TREE;
            "-no-import" : flags := flags + YetiC#CF_NO_IMPORT;
            "-no-frames" : noframes := true;
            "-icast"     : gcj := true;
            ...
            esac,

        compilationOf writer is ~CodeWriter -> ~CompileCtx =
            ctx = new CompileCtx(reader, writer,
                        preload is list?<string> as ~String[],
                        new ClassFinder(classPath is list?<string>));
            if gcj then
                ctx#isGCJ := true
            fi;
            if noframes then
                ctx#classWriterFlags := 0
            fi;
            ctx,

        compileString {source is string,
                       writer is ~CodeWriter,
                       warnings is array<~CompileException>,
                       extraFlags is number} =
            compilation = compilationOf writer;
            type =
                try
                    compilation#compile((), mainClass, source,
                                        flags + extraFlags);
                finally
                    compilation#enumWarns(push warnings)
                yrt;
            TypeDescr#yetiType(type) unsafely_as type,

        compileFiles {basedirs is list?<string>,
                      files is list?<string>,
                      writer is ~CodeWriter,
                      warnings is array<~CompileException>,
                      javaOptions is list?<string>} =
            compilation = compilationOf writer;
            reader#basedirs := basedirs as ~String[];
            try
                mainClass :=
                   compilation#compileAll(sort (list files), flags, javaOptions)
            finally
                compilation#enumWarns(push warnings)
            yrt,

        evaluate params source =
            bindingVars = array [];
            warnings = array [];
            var type = Simple '()';
            writer = new Loader();

            oldContext = YetiEval#get();
            if not defined? evalEnv or contains (ResetEnv ()) params then
                evalEnv := new YetiEval()
            fi;
            YetiEval#set(evalEnv);

            result =
                try
                    bindings = YetiEval#get()#bindings;
                    bindBarrier = bindings#size();
                    type := compileString {source, eval = true, warnings,
                                           writer = writer as ~CodeWriter,
                               extraFlags = YetiC#CF_EVAL + YetiC#CF_EVAL_BIND};
                    val =
                        try
                            Result (execClass params true writer mainClass);
                        catch java.lang.StackOverflowError ex:
                            Exception (ex as ~java.lang.Throwable)
                        catch java.lang.VirtualMachineError ex:
                            // other virtualmachine errors will be rethrown
                            // (including OutOfMemoryError)
                            throw ex
                        catch java.lang.ThreadDeath ex:
                            throw ex // honor thread death also
                        catch java.lang.Throwable ex:
                            Exception ex
                        yrt;

                    for [bindBarrier .. bindings#size() - 1] do i:
                        push bindingVars
                             (bindings#get(i) unsafely_as ~YetiEval$Binding)
                    done;
                    val
                catch CompileException ex:
                    CompileException ex
                finally
                    YetiEval#set(oldContext)
                yrt;

            bindings () =
               (res = array [];
                for bindingVars do binding:
                    if not binding#isImport then
                        t = binding#type;
                        push res "\(if binding#mutable then "var " else "" fi)\
                                 "\(binding#name) is \(t) = \
                                 "\(if t#deref()#type == YetiType#UNIT then
                                        "()"
                                    elif nullptr? binding#value then
                                        "<undef>"
                                    else
                                        Core#show(binding#val())
                                    fi)"
                    fi
                done;
                res);

            {
                warnings, type, result,
            
                get bindings () = list (bindings ()),

                get str () =
                    res = bindings ();
                    case result of
                    Exception ex:
                        push res (stackTraceString ex);
                    CompileException ex:
                        push res (ex is ~CompileException)#getMessage();
                    Result val:
                        if type != Simple "()" then
                            push res
                                 "\(Core#show(val)) is \(showType [] '' type)"
                        fi
                    esac;
                    strJoin '' (map (^ "\n") res),
            },
    }
done;

{
    evalContext, execClass
}
