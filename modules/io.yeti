/*
 * Yeti io library.
 *
 * Copyright (c) 2008 Madis Janson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
module yeti.lang.io;

import java.io.Reader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.BufferedReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.BufferedWriter;
import java.io.FileInputStream;
import java.io.FileOutputStream;

load yeti.lang.std;

var stdin' = () as ~BufferedReader;

lazyReaderHandle reader is (() -> ~BufferedReader) -> '' =
   (var l = [];
    var used = false;
    {
        read num =
            Core#read(reader (), num);

        readln () =
            synchronized reader do:
                if used then
                    Core#UNDEF_STR
                else
                    (reader ())#readLine()
                fi
            done;

        contents () =
            synchronized lazyReaderHandle do:
                if used then
                    Core#UNDEF_STR
                else
                    r = reader ();
                    try
                        Core#readAll(r)
                    finally
                        r#close()
                    yrt
                fi
            done;

        lines () =
            synchronized reader do:
                if used then
                    []
                else
                    l := (ReaderList#lines(reader ()) unsafely_as list<string>);
                    l
                fi
            done;

        close () =
            try
                synchronized reader do:
                    if used then
                        ignore (length l)
                    fi
                done
            finally
                (reader ())#close()
            yrt;
    });

withHandle h block =
    try
        block h
    finally
        h.close ()
    yrt;

{
    norec withHandle = withHandle;

    readln () = stdin.readln ();

    stdin = lazyReaderHandle do:
        if nullptr? stdin' then
            stdin' :=
                new BufferedReader(new InputStreamReader(System#in), 8192);
        fi;
        stdin'
    done;

    print v =
       (System#out#print(v);
        System#out#flush());

    println v =
        System#out#println(v);

    sysExit exitCode =
        System#exit(exitCode);


    readerHandle reader = lazyReaderHandle \reader;

    inputHandle stream encoding is ~InputStream -> string -> '' =
       (var nok = true;
        try
            r = new BufferedReader(
                    if encoding == "" then
                        new InputStreamReader(stream)
                    else
                        new InputStreamReader(stream, encoding)
                    fi, 8192);
            nok := false;
            readerHandle r
        finally
            if nok then
                stream#close()
            fi
        yrt);

    writerHandle writer is ~BufferedWriter -> '' = {
        write s is string -> () =
            writer#write(s);
        writeln s is string -> () =
           (writer#write(s);
            writer#newLine());
        flush () = writer#flush();
        close () = writer#close();
    };

    outputHandle stream encoding is ~OutputStream -> string -> '' =
       (var nok = true;
        try
            w = new BufferedWriter(
                    if encoding == "" then
                        new OutputStreamWriter(stream)
                    else
                        new OutputStreamWriter(stream, encoding)
                    fi);
            nok := false;
            writerHandle w
        finally
            if nok then
                stream#close()
            fi
        yrt);

    linesOfReader reader is ~BufferedReader -> list<string> =
        ReaderList#lines(reader) unsafely_as list<string>;

    openInFile name is string -> string -> '' =
        inputHandle (new FileInputStream(name) as ~InputStream);

    openOutFile name is string -> string -> '' =
        outputHandle (new FileOutputStream(name) as ~OutputStream);

    readFile name encoding =
        withHandle (openInFile name encoding);

    writeFile name encoding =
        withHandle (openOutFile name encoding);

    getLines h = h.lines ();
    putLines h lines = for lines h.writeln;

    getContents h = h.contents ();

    trace msg a = (System#err#print(msg); System#err#println(a); a);
}
