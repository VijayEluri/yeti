/*
 * Yeti io library.
 *
 * Copyright (c) 2008-2011 Madis Janson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/**
 * Standard input/output functions.
 *
 * Exceptions:
 *  java.io.IOException -
 *      Can be thrown for IO errors by any function in this module.
 */
module yeti.lang.io;

import java.io: File, FileInputStream, FileOutputStream,
                Reader, InputStream, InputStreamReader, BufferedReader,
                OutputStream, OutputStreamWriter, BufferedWriter;
import java.lang.Thread;

var stdin' = None ();

typedef input_handle = {
    /// Read a line from the stream.
    read is number -> string,
    readln is () -> string,
    /// Read a full contents of the stream.
    contents is () -> string,
    lines is () -> list<string>,
    close is () -> (),
    rawClose is () -> ()
}

typedef output_handle = {
    close is () -> (),
    flush is () -> (),
    write is string -> (),
    writeln is string -> ()
}

/**
 * Group: read_
 * Create a text input handle object from a Java BufferedReader instance.
 *
 * Arguments:
 * reader - a java.io.BufferedReader instance to be used
 */
readerHandle reader is ~BufferedReader -> 'a =
   (var l = []; // used for forcing on close
    var used = false;
    {
        read num =
            Core#read(reader, num),

        readln () =
            synchronized reader do:
                if used then
                    Core#UNDEF_STR
                else
                    reader#readLine()
                fi
            done,

        contents () =
            synchronized reader do:
                if used then
                    Core#UNDEF_STR
                else
                    used := true;
                    try
                        Core#readAll(reader)
                    finally
                        reader#close()
                    yrt
                fi
            done,

        lines () =
            synchronized reader do:
                if used then
                    []
                else
                    used := true;
                    l := (ReaderList#lines(reader) unsafely_as list<string>);
                    l
                fi
            done,

        close () =
            try
                synchronized reader do:
                    if used then
                        _ = length l
                    fi;
                    used := true
                done
            finally
                reader#close()
            yrt,

        rawClose () =
            synchronized reader do:
                used := true;
                reader#close()
            done
    });

stdin () =
    case stdin' of
    Some rh: rh;
    None _:
       (rh = readerHandle new SafeBufferedReader(
                            new InputStreamReader(System#in));
        stdin' := Some rh;
        rh);
    esac;

/**
 * Group: zmisc (Miscellaneous functions)
 * Apply block to the given handle, after that apply handle.close field
 * to () value, even when exception was thrown by the block (the exception
 * will be passed to caller of withHandle in that case).
 *
 * Arguments:
 * handle - object with close field
 * block  - a function to be applied to the given handle
 */
withHandle h block =
   (try
        block h
    finally
        h.close ()
    yrt);

/**
 * Group: read_
 *
 * Create a text input handle object from a Java InputStream instance.
 * The bytes read from the stream will be converted to text according
 * to the specified encoding. If encoding is empty string, system default
 * charset is used.
 *
 * Arguments:
 * stream   - a java.io.InputStream instance to be used
 * encoding - name of the charset used in the given stream
 */
inputHandle stream encoding is ~InputStream -> string -> 'a =
   (var nok = true;
    try
        r = new SafeBufferedReader(
                    if encoding == "" then
                        new InputStreamReader(stream)
                    else
                        new InputStreamReader(stream, encoding)
                    fi);
        nok := false;
        readerHandle r
    finally
        if nok then
            stream#close()
        fi
    yrt);

/** Group: write_ (Writing text) */
writerHandle writer is ~BufferedWriter -> 'a = {
        write s is string -> () =
            writer#write(s unsafely_as ~String),
        writeln s is string -> () =
            writer#write(s unsafely_as ~String);
            writer#newLine(),
        flush () = writer#flush(),
        close () = writer#close(),
    };

/** Group: write_ */
outputHandle stream encoding is ~OutputStream -> string -> 'a =
   (var nok = true;
    try
        w = new BufferedWriter(
                if encoding == "" then
                    new OutputStreamWriter(stream)
                else
                    new OutputStreamWriter(stream, encoding)
                fi);
        nok := false;
        writerHandle w
    finally
        if nok then
            stream#close()
        fi
    yrt);

/**
 * Group: read_
 * Open text file and create an input handle object for it.
 * The bytes read from the file will be converted to text according
 * to the specified encoding.
 *
 * Arguments:
 * file     - path to the file to be opened
 * encoding - name of the charset used in the given stream
 *            (empty string means system default charset)
 */
openInFile name is string -> string -> 'a =
    inputHandle new FileInputStream(name);

/** Group: write_ */
openOutFile name is string -> string -> 'a =
    outputHandle new FileOutputStream(name);

typedef bin_input_handle = {
    .read is ~byte[] -> number -> number,
    .close is () -> ()
}

/**
 * Group: bin
 * Creates binary handle object for the given input stream.
 *
 * Arguments:
 * input - java.io.InputStream instance to be used
 */
binInputHandle istream is ~InputStream -> 'a = {
        read buf from is ~byte[] -> number -> number =
            istream#read(buf, from, length buf - from),
        close () = istream#close()
    };

/**
 * Group: bin (Binary IO)
 * Creates binary handle object for the given output stream.
 */
binOutputHandle ostream is ~OutputStream -> 'a = {
        write buf len is ~byte[] -> number -> () =
            ostream#write(buf, 0, len),
        close () = ostream#close(),
        flush () = ostream#flush()
    };

{
    withHandle,

    /** Group: read_ (Reading text) */
    readln () = (stdin ()).readln (),

    /** Group: write_ */
    print v =
        System#out#print(v);
        System#out#flush(),

    /** Group: write_ */
    println v =
        System#out#println(v),

    /** Group: write_ */
    eprintln v =
        System#err#println(v),

    /** Group: zmisc */
    sysExit exitCode =
        System#exit(exitCode),

    /** Group: zmisc */
    threadExit exitCode =
        throw new ExitError(exitCode),

    readerHandle,
    inputHandle,
    openInFile,
    writerHandle,
    outputHandle,
    openOutFile,
    binInputHandle,
    binOutputHandle,

    /** Group: read_ */
    get stdin () = stdin (),

    /**
     * Group: read_
     * Deprecated, use (readerHandle reader).lines if you need this functionality.
     */
    linesOfReader reader is ~BufferedReader -> list<string> =
        ReaderList#lines(reader) unsafely_as list<string>,

    /**
     * Group: read_
     * Applies the given block to text input handle opened for specified
     * file. The input handle will be automatically closed afterwards
     * (even when exception was thrown by the block).
     *
     * Arguments:
     * file     - path to the file to be read
     * encoding - name of the charset used in the given stream
     *            (empty string means system default charset)
     * block    - a function to be applied to the opened input object
     */
    readFile name encoding =
        withHandle (openInFile name encoding),

    /** Group: write_ */
    writeFile name encoding =
        withHandle (openOutFile name encoding),

    /**
     * Group: read_
     * Applies the given handle.lines field to () and returns the result.
     *
     * Arguments:
     * handle - a handle object having a lines function field
     *
     * Examples:
     * Can be used together with IO functions expecting a block.
     * : lines = readFile 'example.txt' '' getLines;
     * Reads all lines into a string list from a file named 'example.txt'.
     */
    getLines h = h.lines (),

    /** Group: write_ */
    putLines h lines = for lines h.writeln,

    /**
     * Group: read_
     * Applies the given handle.contents field to () and returns the result.
     *
     * Arguments:
     * handle - a handle object having a contents function field
     *
     * Examples:
     * Can be used together with IO functions expecting a block.
     * : str = readFile 'example.txt' '' getContents;
     * Reads whole contents from a file named 'example.txt' into the str
     * string.
     */
    getContents h = h.contents (),

    /** Group: bin */
    binReadFile name =
        withHandle (binInputHandle new FileInputStream(name is string)),

    /** Group: bin */
    binWriteFile name writer
            is string -> ((~byte[] -> number -> ()) -> 'a) -> 'a =
        withHandle (binOutputHandle new FileOutputStream(name is string))
                   (writer . (.write)),

    /**
     * Group: bin
     * Reads up to limit bytes from input handle and returns function
     * that will apply it's argument to byte[] buffer containing the data
     * and actual number of bytes read.
     *
     * Arguments:
     *  limit - Maximum number of bytes to read (<= 0 means unlimited).
     *  handle - Binary input stream handle.
     *
     * Examples:
     * A contents of file could be copied in the following way:
     * : data = binReadFile "test" (binReadAll 0);
     * : binWriteFile "test2" data;
     *
     * The read data (from previous example) can be easily converted
     * into list<number>:
     * : bytes = data (_ a n = take n a);
     */
    binReadAll limit handle
            is number -> bin_input_handle -> ((~byte[] -> number -> 'a) -> 'a) =
        BinBuf#readAll(limit, handle.read, handle.close) unsafely_as 'b,

    // Example: getContents (openTextUrl [] 'http://example.com/')
    /** Group: zmisc */
    openTextUrl options url
            is list<CharSet (string -> string)> -> string -> 'a =
        conn = new java.net.URL(url unsafely_as ~String)#openConnection();
        stream = conn#getInputStream();
        cs = try
                contentType = conn#getContentType();
                cs = strTrim (strRightOf 'CHARSET=' (strUpper contentType));
                case options of
                CharSet f :: _: f cs;
                _: cs
                esac
             catch java.lang.Throwable t:
                stream#close();
                throw t
             yrt;
        inputHandle stream if cs != '' then cs else 'ISO-8859-1' fi,

    /** Group: write_ */
    trace msg a = (System#err#println(msg); a),

    /**
     * Group: zmisc
     * Create java.lang.Runnable instance that applies the given function
     * to (), when its run method is invoked.
     *
     * Arguments:
     * function - function to apply, when run method is invoked
     */
    runnable f is (() -> ()) -> ~java.lang.Runnable =
        class Run extends java.lang.Runnable
            void run()
                f ()
        end;
        new Run(),

    /** Group: zmisc */
    runThread options f is list?<'a> -> (() -> ()) -> ~Thread =
        th = new Thread(runnable f);
        for options
           \case of
            Daemon (): th#setDaemon(true);
            ClassLoader cl: th#setContextClassLoader(cl);
            esac;
        th#start();
        th,

    /** Group: zmisc */
    sleep time = Thread#sleep(time * 1000),

    /** Group: file (Filesystem operations) */
    deleteFile fn is string -> boolean =
        new File(fn unsafely_as ~String)#delete(),

    /** Group: file */
    createPath path is string -> () = _ =
        new File(path unsafely_as ~String)#mkdirs(),

    /**
     * Group: file
     * Lists files in given directory.
     *
     * Arguments:
     *   hidden    - Include hidden file/directory entries
     *   directory - Path to the directory to list
     */
    listDirectory hidden directory is boolean -> string
            -> list<{name is string, path is string,
                     file? is boolean, directory? is boolean}> =
       (res = array [];
        for new File(directory unsafely_as ~String)#listFiles() do f:
            if hidden or not f#isHidden() then
                var path = f#getPath();
                if File#separator == '\' then
                    path := strReplace '\' '/' path
                fi;
                file? = f#isFile();
                push res {
                    /// Path to the file or directory.
                    path = path,
                    /// Whether this entry denotes a normal file.
                    file? = file?,
                    /// Name without any preceding path.
                    name = f#getName(),
                    /// Whether this entry denotes a directory.
                    directory? = not file? and f#isDirectory()
                }
            fi
        done;
        list res),
}
