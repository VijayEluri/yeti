/*
 * Yeti standard library.
 *
 * Copyright (c) 2008 Madis Janson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
module yeti.lang.std;

import java.lang.String;
import java.lang.IllegalArgumentException;

// like not . f, but a tiny bit faster
notPred f x = not (f x);

// struct inner bindings are non-polymorphic
array l is list?<'a> -> array<'a> =
    new MList(l) unsafely_as array<''>;

head l is list?<'a> -> 'a =
   (if nullptr? l then
        throw new IllegalArgumentException("Empty list")
    fi;
    (l unsafely_as ~AList)#first()) unsafely_as '';

tail l is list?<'a> -> list<'a> =
    if nullptr? l then
        [] // tail of empty list is empty list
    else
        (l unsafely_as ~AList)#rest() unsafely_as list<''>
    fi;

map f l is ('a -> 'b) -> list?<'a> -> list<'b> =
    if empty? l then
        []
    else
        (l unsafely_as ~AList)#map(f) unsafely_as list<''>
    fi;

find f l is ('a -> boolean) -> list?<'a> -> list<'a> =
    if nullptr? l then
        []
    else
        (l unsafely_as ~AList)#find(f) unsafely_as list<'a>
    fi;

index v l is 'a -> list?<'a> -> number =
    if nullptr? l then
        -1
    else
        res = (l unsafely_as ~AList)#index(v);
        if nullptr? res then -1 else res fi
    fi;

{
    id x = x;
    const x y = x;
    ignore x = ();
    at h k = h.[k];

    // functions for standard operators
    norec not v = not v;
    norec (and) a b = a and b;
    norec (or) a b = a or b;
    norec (in) a b = a in b;
    norec (==) a b = a == b;
    norec (!=) a b = a != b;
    norec (<)  a b = a <  b;
    norec (<=) a b = a <= b;
    norec (>)  a b = a >  b;
    norec (>=) a b = a >= b;
    norec (+)  a b = a + b;
    norec (-)  a b = a - b;
    norec (*)  a b = a * b;
    norec (/)  a b = a / b;
    norec (%)  a b = a % b;
    norec (.)  a b = a . b;
    norec (::) v l = v :: l;
    norec (:.) v l = v :. l;
    norec (=~) s p = s =~ p;
    norec (div) a b = a div b;
    norec (shl) a b = a shl b;
    norec (shr) a b = a shr b;
    norec negate a = negate a;
    norec nullptr? a = nullptr? a;
    norec defined? a = defined? a;
    norec empty? a = empty? a;
    norec same? a b = same? a b;
    norec synchronized monitor block = synchronized monitor block;
    (^) a b = "\(a)\(b)";
    (++) a b is list?<'a> -> list?<'a> -> list<'a> =
        if empty? a then
            b
        elif empty? b then
            a
        else
            new ConcatList(a, b) unsafely_as list<'a>
        fi;

    // damn struct polymorphism restriction. is it really needed?
    norec array = array;
    norec tail = tail;
    norec head = head;
    norec map = map;
    norec find = find;
    norec index = index;

    wrapArray a is 'a[] -> array<'a> =
        new MList(a) unsafely_as array<''>;

    flip f x y =
        f y x;
    number x =
        Core#parseNum(x is string);
    min a b =
        if a < b then a else b fi;
    max a b =
        if a > b then a else b fi;
    abs a =
        if a < 0 then -a else a fi;
    concat l =
        fold (++) [] l;
    concatMap f =
        concat . (map f);
    any f l =
        not (nullptr? (find f l));
    all f l =
        nullptr? (find (notPred f) l);
    contains v l =
        index v l != -1;
    fromSome default f opt =
        case opt of
        Some v: f v;
        None _: default;
        esac;

    splitBy pred list is (('a -> boolean) -> list<'a> ->
                          { fst is list<'a>; snd is list<'a> }) = 
       (a = new MList();
        var l = list; // over-optimized loop from hell. don't code like that.
        not (empty? l) and (h = head l; not (pred h) and (a#add(h); true)) loop
            l := tail l;
        { fst = if a#isEmpty() then [] else a unsafely_as list<''> fi;
          snd = l });

    take n l is number -> list?<'a> -> list<'a> =
        TakeList#take(l, n) unsafely_as list<''>;

    iterate f x is ('a -> 'a) -> 'a -> list<'a> =
        new Iterate(x, f) unsafely_as list<''>;

    // few math functions
    pi = Math#PI;
    ln a = Math#log(a);
    exp a = Math#exp(a);
    cos a = Math#cos(a);
    sin a = Math#sin(a);
    tan a = Math#tan(a);
    acos a = Math#acos(a);
    asin a = Math#asin(a);
    atan a = Math#atan(a);
    sqrt a = Math#sqrt(a);

    strReplace needle replacement haystack =
        Core#replace(needle, replacement, haystack);

    // TODO ineffective
    strSplit re s is string -> string -> list?<string> =
        new MList((s as ~String)#split(re))
            unsafely_as list?<string>;

    // TODO ineffective
    substAll re replacement s is string -> string -> string -> string =
        (s as ~String)#replaceAll(re, replacement);

    norec strLength s = strLength s;
    norec strUpper s = strUpper s;
    norec strLower s = strLower s;
    norec strTrim s = strTrim s;
    norec strSlice s start end = strSlice s start end;
    norec strRight s pos = strRight s pos;
    norec strStartsWith s start = strStartsWith s start;
    norec strEndsWith s end = strEndsWith s end;
    norec strIndexOf haystack needle = strIndexOf haystack needle;
    norec strLastIndexOf haystack needle = strLastIndexOf haystack needle;

    strLeft s end = strSlice s 0 end;

    strLeftOf subString s is string -> string -> string =
       (i = strIndexOf s subString 0;
        if i < 0 then '' else strSlice s 0 i fi);

    strRightOf subString s is string -> string -> string=
       (i = strLastIndexOf s subString 0;
        if i < 0 then '' else strRight s (i + strLength subString) fi);

    forHash h f is hash<'a, 'b> -> ('a -> 'b -> ()) -> () =
       (i = (h unsafely_as ~Hash)#entrySet()#iterator();
        i#hasNext() loop
           (e = i#next() unsafely_as ~java.util.Map$Entry;
            f (e#getKey() unsafely_as 'a) (e#getValue() unsafely_as 'b)));

    mapHash f h is ('a -> 'b -> 'c) -> hash<'a, 'b> -> list?<'c> =
       (a = new MList();
        a#reserve((h unsafely_as ~Hash)#size());
        i = (h unsafely_as ~Hash)#entrySet()#iterator();
        i#hasNext() loop
           (e = i#next() unsafely_as ~java.util.Map$Entry;
            a#add(f (e#getKey() unsafely_as 'a)
                    (e#getValue() unsafely_as 'b)));
        a unsafely_as list?<''>);

    setHashDefault h f is hash<'a, 'b> -> ('a -> 'b) -> () =
        (h unsafely_as ~Hash)#defaultFun := (f unsafely_as ~Fun);

    length l is list?<''> -> number =
        if nullptr? l then
            0
        else
            (l unsafely_as ~AList)#length()
        fi;

    setArrayCapacity a n is array<'a> -> number -> () =
        (a unsafely_as ~MList)#reserve(n);

    shift a is array<'a> -> 'a =
        (a unsafely_as ~MList)#shift() unsafely_as 'a;

    push a v is array<'a> -> 'a -> () =
        (a unsafely_as ~MList)#add(v);

    filter f l is ('a -> boolean) -> list?<'a> -> list<'a> =
        if empty? l then
            []
        else
            FilterList#filter(l, f) unsafely_as list<'a>
        fi;

    catSome l is list?<Some 'a | None 'b> -> list<'a> =
        if empty? l then
            []
        else
            CatSomes#filter(l) unsafely_as list<'a>
        fi;

    map2 f a b is ('a -> 'b -> 'c) -> list?<'a> -> list?<'b> -> list<'c> =
        if empty? a or empty? b then
            []
        else
            new Map2List(f, a, b) unsafely_as list<'c>
        fi;

    reverse l is list?<'a> -> list<'a> =
        if nullptr? l then
            []
        else
            (l unsafely_as ~AList)#reverse() unsafely_as list<'a>
        fi;
}
