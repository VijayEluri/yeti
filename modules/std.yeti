/// Yeti standard library

/*
 * Copyright (c) 2008,2009 Madis Janson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
module yeti.lang.std;

import java.lang.IllegalArgumentException;
import java.util.regex.Pattern;
import java.util.Map;

class FailureException(String what)
    extends RuntimeException(what)
end;

/// Identity function (I combinator). The argument value will be
/// returned as is (id x = x).
id x = x;

/**
 * Creates a new array containing elements from the init list.
 *
 * Arguments:
 *  init - elements in this list will be added into the new array
 *
 * Examples:
 *
 * Create an empty array and add some value:
 * : someArray = array [];
 * : push someArray "test";
 * 
 * Create an array containing some given elements:
 * : numbers = array [1..5];
 */
array l is list?<'a> -> array<'a> =
    new MList(l) unsafely_as array<'a>;

/**
 * Takes value and first element of the list and applies those to the given
 * function, then repeats with following list elements, using the result from
 * previous application as the new value. Returns the result of last
 * application (or initial value when empty list was given).
 *
 * Arguments:
 *  function - two-argument function used for folding
 *  value - initial value
 *  list - list to fold
 *
 * Examples:
 * : fold function value [a, b, c]
 *
 * is equivalent to:
 * : ((value `function` a) `function` b) `function` c
 *
 * Calculate a sum of list:
 * : sum l = fold (+) 0 l;
 *
 * Calculate a factorial:
 * : factorial n = fold (*) 1 [1..n];
 *
 * The fold function could be implemented in the following way:
 * : fold function value list =
 * :     case list of
 * :     x :: xs: fold function (function value x) xs;
 * :     _: value;
 * :     esac;
 */
fold f is ('a -> 'b -> 'a) -> 'a -> list?<'b> -> 'a =
   (f2 v l is 'a -> list?<'b> -> 'a = // hack to get good code for gc
        if nullptr? l then
            v
        else
            (l unsafely_as ~AList)#fold(f, v) unsafely_as 'a
        fi;
    f2);

/**
 * Finds a list element, for which the predicate function returns true
 * and returns the list tail starting from that element, or empty list
 * when the given predicate isn't true for any list element.
 *
 * Arguments:
 *  predicate - function that returns true for the searched value
 *  list      - list to be searched
 *
 * Examples:
 *  : find (== 3) [1..5] // gives a list [3, 4, 5]
 */
find f l is ('a -> boolean) -> list?<'a> -> list<'a> =
    if nullptr? l then
        []
    else
        (l unsafely_as ~AList)#find(f) unsafely_as list<'a>
    fi;

/**
 * Returns 0-based index of the first list element, which equals
 * to the given value (using == for equality).
 *
 * Arguments:
 *  value - value to search for
 *  list  - list to be searched
 *
 * Examples:
 *  : index (== 'apple') ['oranges', 'apples', 'rats'] // returns 1
 */
index v l is 'a -> list?<'a> -> number =
    if nullptr? l then
        -1
    else
        res = (l unsafely_as ~AList)#index(v);
        if nullptr? res then -1 else res fi
    fi;

/**
 * Returns list of hash map keys.
 *
 * Arguments:
 *  hash - the hash map
 */
keys h is hash<'a, 'b> -> list<'a> =
    if empty? h then
        []
    else
        new MList((h unsafely_as ~Map)#keySet()#toArray())
            unsafely_as list<'a>
    fi;

/**
 * Creates a hash mapping from given list elements to unit values (you can
 * think of it being a set). As the hash map is essentially unordered,
 * the ordering that was present in the given list will be lost.
 *
 * Arguments:
 *  list - values to use as hash keys
 *
 * Examples:
 * : hash [11, 22] // returns [11: (), 22: ()]
 */
hash l is list?<'a> -> hash<'a, ()> =
   (h = [:];
    for l (_ i = h.[i] := ());
    h);

/**
 * Iterates over hash map, calling the block function for each
 * hash map entry with key and value as arguments.
 *
 * Arguments:
 *  hash  - hash map to iterate
 *  block - function to call
 *
 * Examples:
 *
 * Print each hash map key-value pair on separate line.
 * : h = ['test': 54, 'that': 42];
 * : forHash h do k v:
 * :    println "\(k): \(v)\n";
 * : done
 */
forHash h f is hash<'a, 'b> -> ('a -> 'b -> ()) -> () =
    // warning: it's also used as forMap implementation
   (i = (h unsafely_as ~Map)#entrySet()#iterator();
    i#hasNext() loop
       (e = i#next() unsafely_as ~java.util.Map$Entry;
        f (e#getKey() unsafely_as 'a) (e#getValue() unsafely_as 'b)));

/**
 * Returns [function(a), function(b), ...] for list [a, b, ...]
 * by applying the function to each element of the list (either
 * lazily or strictly).
 *
 * Arguments:
 *  function - function applied to list elements
 *  list - list to be processed
 *
 * Description:
 * A lazy list is returned when applied on normal list. Full result
 * is not calculated in this case on application, but lazily as the
 * result is consumed by caller. Arrays and lists backed by arrays
 * are mapped strictly.
 *
 * You should ALWAYS use the strict map' instead, if the mapping function
 * has side effects, as it's not determined whether function is applied
 * by map on some list element when map was called, some time later or
 * even never at all (if the result list was not consumed).
 */
map f l is ('a -> 'b) -> list?<'a> -> list<'b> =
    if empty? l then
        []
    else
        (l unsafely_as ~AList)#map(f) unsafely_as list<'b>
    fi;

/**
 * Returns strict [function(a), function(b), ...] for list [a, b, ...]
 * by applying the function to each element of the list.
 *
 * Arguments:
 *  function - function applied to list elements
 *  list - list to be processed
 *
 * Description:
 * It is similar to map function, but never creates a lazy list.
 * The map' is usually faster than map on lists, unless huge streams
 * are processed or most of the resulting list is not used. It works
 * identically to map on arrays.
 */
map' f l is ('a -> 'b) -> list?<'a> -> list<'b> =
    if empty? l then
        []
    else
        (l unsafely_as ~AList)#smap(f) unsafely_as list<'b>
    fi;

/**
 * Returns count of elements in container.
 *
 * Arguments:
 *   container - a list, array or hash map
 *
 * Description:
 * For list or array it's length is returned, and for hash map the number of
 * key-value pairs in that hash map. The length function can also be applied
 * to Java arrays (for example length new int[10]), as Yeti compiler wraps
 * these automatically into lists on function arguments.
 */
length l is map<'a, 'b> -> number =
    if nullptr? l then
        0
    else
        (l unsafely_as ~Coll)#length()
    fi;

/**
 * Access any value at runtime. Returns variant tagged with values
 * runtime type.
 *
 * The peekObject function may not be always accurate, as full type
 * information is not available at runtime (for example empty list is
 * indistinguishable from (), element types of empty collections
 * remain unknown and function types cannot be determined).
 *
 * Arguments:
 *   value - value to peek into
 */
peekObject object =
   (o = object as ~Object;
    if nullptr? o then
        List []
    elif o instanceof String then
        String (o unsafely_as string)
    elif o instanceof Num then
        Number (o unsafely_as number)
    elif o instanceof Boolean then
        Boolean (o unsafely_as boolean)
    elif o instanceof AList then
        List (map peekObject (o unsafely_as list<'a>))
    elif o instanceof ByKey then
        result = [:];
        i = (o unsafely_as ~Map)#entrySet()#iterator();
        i#hasNext() loop
           (e = i#next() unsafely_as ~java.util.Map$Entry;
            result.[peekObject (e#getKey() unsafely_as 'a)] :=
                peekObject (e#getValue() unsafely_as 'a));
        Hash result
    elif o instanceof Struct then
        st = o unsafely_as ~Struct;
        fields = map' (_ n = st#name(n)) [0 .. st#count() - 1];
        Struct {
            fields,
            value name =
                i = (fields unsafely_as ~AList)#index(name is string);
                if nullptr? i then
                    throw new NoSuchKeyException("No such field (\(name))")
                fi;
                peekObject (st#get(i) unsafely_as 'a)
        }
    elif o instanceof Tag then
        t = o unsafely_as ~Tag;
        Variant {tag = t#name, value = peekObject (t#value unsafely_as 'a)}
    else
        Object o
    fi);

plus a b = a + b;

{
    /**
     * None () value short-hand constant.
     */
    none = None (),

    /**
     * K combinator - returns constant function \x (which returns value
     * of the (first) argument x).
     *
     * Arguments:
     * x - value to be returned by resulting function (const x () is same as x).
     */
    const x = (_ = (); \x),

    /**
     * Application in reverse order. Expression (value |> function)
     * is equivalent to (function value).
     *
     * Arguments:
     * value - value given as argument to the function
     * function - function to apply
     *
     * Description:
     * The |> operator can be used to pipe value of expression through multiple
     * functions. Calls to |> are usually inlined into direct application by Yeti
     * compiler (if possible). Due to low priority (just above type operators is
     * and as) the parenthesis around function and argument expressions can be
     * omitted usually.
     *
     * Examples:
     * : a = iterate (+ 1) 0 |> take 5 |> map (*2);
     *
     * is same as:
     * : a = map (*2) (take 5 (iterate (+ 1) 0));
     *
     * both resulting with a = [0,2,4.6,8].
     */
    (|>) arg f = f arg,

    /**
     * Array/hash subscription operator collection.[key] as function.
     * Returns element at corresponding key (index).
     *
     * Arguments:
     * collection - array or hash table
     * key - array index or hash table key
     *
     * Exceptions:
     * NoSuchKey - if the key doesn't exist in the given collection
     *
     * Examples:
     * : numbers = [1: "one", 2: "two", 3: "three"];
     * : println (map (at numbers) [3, 1]); // ["three","one"]
     */
    at h k = h.[k],

    /**
     * Binary function composition. Composes binary f and
     * unary g so that arguments to f are transformed by appling g.
     *
     * Arguments:
     * f - binary function
     * g - unary function used to transform arguments to f
     *
     * Description:
     * : on f g x y = f (g x) (g y)
     *
     * Examples:
     * : list = [{name="X",v=6},{name="A",v=33}];
     * : sorted = sort (on (<) (.name)) list;
     *
     * The list is sorted by name structure field.
     */
    on f g is ('a -> 'a -> 'b) -> ('c -> 'a) -> 'c -> 'c -> 'b =
        new On(f, g) unsafely_as 'a, 

    /**
     * Logical negation of the value.
     *
     * Arguments:
     * value - logical value
     */
    norec (not) v = not v,

    /**
     * Logical conjunction of a and b.
     *
     * Arguments:
     * a - first value
     * b - second value
     */
    norec (and) a b = a and b,

    /**
     * Logical disjunction of a or b.
     *
     * Arguments:
     * a - first value
     * b - second value
     */
    norec (or) a b = a or b,

    /**
     * Checks whether a key exists in the hash map.
     *
     * Arguments:
     * key - key value to search for
     * hash - hash map to be checked
     *
     * Examples:
     * : h = ['a': 11, 'b': 22];
     * : printKey k =
     * :     if k in h then
     * :         println "h.[\(k)] = \(h.[k])"
     * :     else
     * :         println "\(k) doesn't exist"
     * :     fi;
     * : printKey 'b'; // prints h.[b] = 22
     * : printKey 'c'; // prints c doesn't exist
     */
    norec (in) a b = a in b,

    /**
     * Returns true when a and b values are equal (and false otherwise).
     *
     * It is internally implemented on most data types using .equals()
     * method on the corresponding JVM value.
     *
     * Arguments:
     * a - first value
     * b - second value
     */
    norec (==) a b = a == b,

    /**
     * Returns true when a and b values are not equal (and false otherwise).
     *
     * It is internally implemented on most data types using .equals()
     * method on the corresponding JVM value.
     *
     * Arguments:
     * a - first value
     * b - second value
     */
    norec (!=) a b = a != b,

    /**
     * Returns true when a value is less than b value (and false otherwise).
     *
     * It is internally implemented on most data types using
     * Comparable.compareTo() method on the corresponding JVM value.
     *
     * Arguments:
     * a - first value
     * b - second value
     */
    norec (<)  a b = a <  b,

    /**
     * Returns true when a value is less than or equal to b value
     * (and false otherwise).
     *
     * It is internally implemented on most data types using
     * Comparable.compareTo() method on the corresponding JVM value.
     *
     * Arguments:
     * a - first value
     * b - second value
     */
    norec (<=) a b = a <= b,

    /**
     * Returns true when a value is greater than b value (and false otherwise).
     *
     * It is internally implemented on most data types using
     * Comparable.compareTo() method on the corresponding JVM value.
     *
     * Arguments:
     * a - first value
     * b - second value
     */
    norec (>)  a b = a >  b,

    /**
     * Returns true when a value is greater than or equal to b value
     * (and false otherwise).
     *
     * It is internally implemented on most data types using
     * Comparable.compareTo() method on the corresponding JVM value.
     *
     * Arguments:
     * a - first value
     * b - second value
     */
    norec (>=) a b = a >= b,

    /**
     * Arithmetic sum of the values a and b.
     *
     * The result may not be accurate when applied to rational numbers
     * with very big numerator or denominator part as these overflow into
     * double-precision floating point numbers.
     *
     * Arguments:
     * a - first number
     * b - second number
     */
    norec (+)      = plus,

    /**
     * Substracts subtrahend from minuend and returns the difference.
     *
     * The result may not be accurate when applied to rational numbers
     * with very big numerator or denominator part as these overflow into
     * double-precision floating point numbers.
     *
     * Arguments:
     * minuend    - number to substract from
     * subtrahend - number to substract
     */
    norec (-)  a b = a - b,

    /**
     * Arithmetic product of the values a and b.
     *
     * The result may not be accurate when applied to rational numbers
     * with very big numerator or denominator part as these overflow into
     * double-precision floating point numbers.
     *
     * Arguments:
     * a - first number
     * b - second number
     */
    norec (*)  a b = a * b,

    /**
     * Divides dividend with divisor and returns the quotient.
     *
     * The result is rational number, when integer values fitting into
     * 32 bits are divided.
     *
     * The result may not be accurate when applied to big integers or
     * rational numbers with very big numerator or denominator part as
     * these overflow into double-precision floating point numbers.
     *
     * Arguments:
     * dividend - the number to divide
     * divisor  - dividend is divided by divisor
     */
    norec (/)  a b = a / b,

    /**
     * Remainder of division of the integer part of dividend
     * with integer part of divisor.
     *
     * Arguments:
     * dividend - the number to divide
     * divisor  - dividend is divided by divisor
     */
    norec (%)  a b = a % b,

    /**
     * Function composition - (f . g) x is same as f (g x).
     * Composes unary f and g into single function, where f is
     * applied to the result of application of g (to argument).
     *
     * Arguments:
     * f - first function
     * g - second function
     *
     * Examples:
     * : printLength = print . length;
     * : printLength [4,5,6]; // prints 3
     *
     * This is equivalent to:
     * : printLength x = print (length x);
     * : printLength [4,5,6]; // prints 3
     */
    norec (.)  a b = a . b,

    /**
     * Constructs a new list by prepending value to tail list.
     *
     * Arguments:
     * value - value to be prepended
     * list  - list used as tail of the constructed list
     *
     * Examples:
     * The following expressions result in equivalent lists.
     * : a :: [b, c] == [a, b, c]
     */
    norec (::) v l = v :: l,

    /**
     * Constructs a new list from head value and function that would return
     * the tail list. The function will be applied once, when the list
     * tail is requested for the first time. This allows creating lazy and
     * possibly infinite lists or streams.
     *
     * Arguments:
     * value    - value used as new list head
     * function - function that would return the list tail, when applied
     *            to unit value
     */
    norec (:.) v l = v :. l,

    /**
     * Returns true when regular expression has a match in the haystack string
     * (and false otherwise).
     *
     * Arguments:
     * haystack - string where to search the given regex match
     * regex    - string representing a regular expression
     *
     * Description:
     * The regular expression is compiled and matched using the java.util.regex
     * implementation, and therefore uses the same (Perl regular expression
     * compatible) syntax. Yeti compiler optimises usage of this operator
     * when literal string is used as regex argument, so that the regex will
     * be compiled only once into the java.util.regex.Pattern instance.
     *
     * Examples:
     * : if str =~ '\d' then
     * :     println "'\(str)' contains a number in it."
     * : fi
     */
    norec (=~) s p = s =~ p,

    /**
     * Returns true when regular expression has no match in the haystack string
     * (and false if it has).
     *
     * Arguments:
     * haystack - string where to search the given regex match
     * regex    - string representing a regular expression
     *
     * Description:
     *
     * This operator is negation of the =~ operator and could be defined in the
     * following way:
     * : (!~) haystack regex = not (haystack =~ regex)
     *
     * The regular expression is compiled and matched using the java.util.regex
     * implementation, and therefore uses the same (Perl regular expression
     * compatible) syntax. Yeti compiler optimises usage of this operator
     * when literal string is used as regex argument, so that the regex will
     * be compiled only once into the java.util.regex.Pattern instance.
     *
     * Examples:
     * : if str !~ '\d' then
     * :     println "'\(str)' has no number in it."
     * : fi
     */
    norec (!~) s p = s !~ p,

    /**
     * Divides integer part of dividend with integer part of divisor
     * and returns the integer part of quotient.
     *
     * Arguments:
     * dividend - the number to divide
     * divisor  - dividend is divided by integer part of divisor
     */
    norec (div) a b = a div b,

    /**
     * Shifts bit representation of integer part of the value
     * to left by given count of bits and returns the result.
     *
     * Arguments:
     * value - the value to shift
     * count - how much shift
     */
    norec (shl) a b = a shl b,

    /**
     * Shifts bit representation of integer part of the value
     * to right by given count of bits and returns the result.
     *
     * Arguments:
     * value - the value to shift
     * count - how much shift
     */
    norec (shr) a b = a shr b,

    /**
     * Returns bitwise XOR of integer parts of arguments a and b.
     *
     * Arguments:
     * a - first number
     * b - second number
     */
    norec (xor) a b = a xor b,

    /**
     * Returns bitwise OR of integer parts of arguments a and b.
     *
     * Arguments:
     * a - first number
     * b - second number
     */
    norec (b_or) a b = a b_or b,

    /**
     * Returns bitwise AND of integer parts of arguments a and b.
     *
     * Arguments:
     * a - first number
     * b - second number
     */
    norec (b_and) a b = a b_and b,

    /**
     * Returns algebralic negation of argument value (negate value = -value).
     *
     * Arguments:
     * value - value to negate
     */
    norec negate a = negate a,

    /**
     * Check whether given value is a JVM null pointer, and returns true
     * when it is.
     *
     * Arguments:
     * value - value to check
     *
     * Notes:
     * Use defined? instead, unless you really know what you're doing.
     * The low-level check done by nullptr? may behave unexpectedly
     * together with some conversions done by Yeti compiler (for example
     * nullptr? (System#getenv('???')) is always false).
     */
    norec nullptr? a = nullptr? a,

    /**
     * Checks whether given value is defined, and returns true when it is.
     * Undefined values are JVM null pointer, undef_str and undef_bool.
     *
     * Arguments:
     * value - value to check
     *
     * Notes:
     * The unit value () is internally represented by JVM null pointer,
     * and therefore defined? () is false.
     *
     * Empty lists are often also considered to be undefined because
     * of being represented by null pointer (but empty arrays are not).
     * You should use empty? to detect empty lists.
     */
    norec defined? a = defined? a,

    /**
     * Checks whether a collection is empty, and returns true when it is.
     *
     * This function works on all kinds of standard collections - lists,
     * arrays and hashes implement the map<> interface.
     *
     * Arguments:
     * collection - collection to check
     */
    norec empty? a = empty? a,

    /**
     * Returns the first element of sequence (which must be non-empty).
     *
     * Arguments:
     * sequence - the list or array from which to extract the first element
     *
     * Exceptions:
     * java.lang.NullPointerException - when used on empty list
     * yeti.lang.EmptyArrayException  - when used on empty array
     */
    norec head a = head a,

    /**
     * Returns the tail of sequence consisting of all elements except
     * the first (head) one. Using tail is equivalent to using drop 1.
     *
     * Arguments:
     * sequence - the list or array to use
     *
     * Notes:
     * The tail function can be used on array. In this case a list view
     * of array is returned, consisting of all elements starting from
     * index 1 (subsequent applications of tail give views with increased
     * start index). As the list view still references to the original
     * array, it will change when the array is modified (use copy function
     * to get an independent copy).
     */
    norec tail a = tail a,

    /**
     * Identity check - returns true when a and b reference to the same
     * object instance (and false otherwise).
     *
     * Arguments:
     * a - first value reference
     * b - second value reference
     *
     * Notes:
     * It is equivalent to Java == operator (barring primitive values,
     * which don't exist in Yeti anyway).
     */
    norec same? a b = same? a b,

    /**
     * Iterates over sequence, appling the block function to the element
     * value for each sequence element.
     *
     * Arguments:
     *  sequence - list or array to iterate
     *  block    - function to call
     *
     * Examples:
     *
     * Print numbers from 1 to 100, using for on range list.
     * : for [1..100] do i:
     * :     println i
     * : done
     */
    norec for l f = for l f,

    /**
     * Acquires an intrinsic monitor lock on behalf of the executing thread,
     * applies the block to (), then releases the lock. It is equivalent to
     * executing the block in Java synchronized block.
     * 
     * Arguments:
     *  monitor - object that is used for the lock (value of any type can
     *            be use as long as nullptr? monitor is false)
     *  block   - function that is applied while the monitor lock is hold
     *
     * Exceptions:
     *  java.lang.NullPointerException - when monitor is a JVM null pointer
     *
     * Examples:
     * : var nameCount = 0;
     * : var lastName = '';
     * :
     * : addName name =
     * :     synchronized addName do:
     * :          lastName := name;
     * :          nameCount := nameCount + 1;
     * :     done;
     *
     * The addName function is used as a monitor here.
     */
    norec synchronized monitor block = synchronized monitor block,

    /**
     * Returns the result of concatenating strings a and b.
     *
     * Arguments:
     * a - first string
     * b - second string
     *
     * Notes:
     * Using this operator is equivalent to the embedded string expression
     * "\(a)\(b)" except for requiring the arguments to be of string type.
     */
    (^) a b is string -> string -> string = "\(a)\(b)",

    /**
     * Appends two sequences a and b lazily, returns the resulting list.
     *
     * Arguments:
     * a - first sequence (list or array)
     * b - second sequence (list or array)
     *
     * Description:
     * The list append operator creates a lazy list, which copies
     * the first sequence on the fly (as elements are requested),
     * and when it ends, gives the second sequence as the list tail.
     *
     * If first sequence (a) is an infinite list, then the result is
     * equivalent to it.
     *
     * If the second sequence (b) is an array, and is later mutated,
     * then the resulting list will see the modified array as its tail
     * (use copy function to get an independent copy).
     *
     * Examples:
     * : for ([1..4] ++ [13..15]) println;
     *
     * Prints numbers 1, 2, 3, 4, 13, 14, 15. No list containing those
     * numbers is never allocated (as lazy ranges are lazily appended).
     */
    (++) a b is list?<'a> -> list?<'a> -> list<'a> =
        if empty? a then
            b as ~Object unsafely_as 'a
        elif empty? b then
            a as ~Object unsafely_as 'a
        else
            new ConcatList(a, b) unsafely_as list<'a>
        fi,

    // damn struct polymorphism restriction. is it really needed?
    array, fold, find, id, index, keys, hash, map, map',
    forHash, length, peekObject,

    /// Wraps Java array object into Yeti array type.
    wrapArray is 'a[] -> array<'a> = id,

    /**
     * Returns a list of elements obtained by applying the function
     * to each element of the Java collection.
     *
     * Arguments:
     *  function - function applied to list elements
     *  collection - java.util.Collection instance (may be null,
     *               empty list is returned in this case)
     */
    mapJavaList f l is (~Object -> 'a) -> ~java.util.Collection -> list<'a> =
        if nullptr? l then
            []
        else
            map f l#toArray()
        fi,

    /**
     * Iterates over Java map, calling the block function for each
     * map entry with key and value as arguments.
     *
     * Arguments:
     *  map   - java.util.Map instance to iterate
     *  block - function to call
     *
     * Examples:
     * : forJavaMap System#getProperties() do name value:
     * :    println {name, value}
     * : done
     * Prints system properties.
     */
    forJavaMap = forHash unsafely_as ~yeti.lang.Fun unsafely_as
        ~java.util.Map -> (~Object -> ~Object -> ()) -> (),

    /**
     * Gives values from collection as a list.
     *
     * Arguments:
     * collection - a list, array or hash map
     *
     * Description:
     * List is returned as is. A list view is returned for an array
     * (implementation wise just a type cast), so it will change when the
     * original array is modified. Differently from array, an independent
     * list consisting of values from the key-value pairs is created and
     * returned when the collection is a hash map.
     *
     * Either returned list or collection given as argument should be
     * explicitly copied (using copy function), if you want to store the
     * result for later usage and the original collection might change.
     *
     * Relying on the mutating list-view of an array is best
     * to be avoided - having direct reference to the original
     * collection is more straight-forward solution.
     */
    list a is map<'k, 'a> -> list<'a> =
        if empty? a then
            []
        else
            (a unsafely_as ~Coll)#asList() unsafely_as list<'a>
        fi,

    /// Swaps elements with keys i and j in mapping a
    swapAt a i j =
        x = a.[i];
        a.[i] := a.[j];
        a.[j] := x,

    /// Applies function to two arguments in reversed order.
    /// Useful for swapping binary functions arguments.
    flip f x y =
        f y x,

    /// Make function f to be memoizing.
    lazy f is (() -> 'a) -> (() -> 'a) =
        new Lazy(f) unsafely_as (() -> 'a),

    /// Construct a pair structure.
    pair fst snd =
        {fst, snd},

    /// Convert any value into string representation
    string x =
        "\(x)",

    /// Convert string into number
    number x =
        Core#parseNum(x is string unsafely_as ~String),

    /// Numeric functions
    min a b =
        if a < b then a else b fi,
    max a b =
        if a > b then a else b fi,
    abs a =
        if a < 0 then -a else a fi,
    sum l =
        fold plus 0 l,

    /// Flatten a list of lists.
    concat l is list?<list?<'a>> -> list<'a> =
        if empty? l then
            []
        else
            ConcatLists#concat(l) unsafely_as list<'a>
        fi,

    /// Basically concat . map, but more effective.
    concatMap f l is ('a -> list?<'b>) -> list?<'a> -> list<'b> =
        if empty? l then
            []
        else
            concat ((l unsafely_as ~AList)#map(f) unsafely_as list<'a>)
        fi,

    /// Is predicate f true for any element of list l?
    any f l =
        not nullptr? (find f l),

    /// Is predicate f true for all elements of list l?
    all f l =
        nullptr? (find (_ x = not f x) l),

    /// Returns first element of l for which predicate f is false
    /// or last element, when f returns false for all elements of l.
    avoid f l is ('a -> boolean) -> list?<'a> -> 'a =
        if empty? l then
            throw new IllegalArgumentException("prefer: empty list")
        fi;
        var i = l unsafely_as ~AIter;
        var value = () as ~Object;
        (value := i#first();
         i := i#next();
         not nullptr? i and f (value unsafely_as 'a)) loop;
        value unsafely_as 'a,

    /// Whether l contains element equal (as defined by (==)) to v
    contains? v l is 'a -> list?<'a> -> boolean =
        not (nullptr? l or nullptr? (l unsafely_as ~AList)#index(v)),

    /// deprecated!!!
    contains v l = contains? v l,

    /// Returns default when opt == None () and f x when opt == Some x
    maybe default f opt =
        case opt of
        Some v: f v;
        None _: default;
        esac,

    /// Splits given list into two parts, putting elements from the start of the
    /// list into fst as long as predicate function pred is false for the given
    /// element. The rest of the list is returned as snd.
    splitBy pred list is ('a -> boolean) -> list<'a>
                          -> { fst is list<'a>, snd is list<'a> } = 
        a = new MList();
        var l = list; // over-optimized loop from hell. don't code like that.
        not empty? l and (h = head l; not pred h and (a#add(h); true)) loop
            l := tail l;
        { fst = if a#isEmpty() then [] else a unsafely_as list<'a> fi,
          snd = l },

    /// Splits given list into two parts, returning first n elements as fst
    /// and the rest as snd.
    splitAt n list is number -> list<'a>
                      -> { fst is list<'a>, snd is list<'a> } =
        a = new MList();
        var l = list;
        var n = n;
        if n < 256 then
            a#reserve(n)
        fi;
        n > 0 and not empty? l loop
           (a#add(head l);
            l := tail l;
            n := n - 1);
        { fst = if a#isEmpty() then [] else a unsafely_as list<'a> fi,
          snd = l },

    /// Take first n elements from list l
    take n l is number -> list?<'a> -> list<'a> =
        if nullptr? l then
            []
        else
            TakeList#take(l, n) unsafely_as list<'a>
        fi,

    /// Drop first n elements from list l. Won't copy the returned tail.
    drop n l =
        if n <= 0 then
            l
        elif empty? l then
            []
        else
            drop (n - 1) (tail l)
        fi,

    /// Take elements from the start of list l while predicate pred
    /// is true on the element.
    takeWhile pred l is ('a -> boolean) -> list<'a> -> list<'a> =
        if empty? l then
            []
        else
            TakeWhile#take(l, pred) unsafely_as list<'a>
        fi,

    /// Returns infinite list [x, f(x), f(f(x)), f(f(f(x))), ...]
    iterate f x is ('a -> 'a) -> 'a -> list<'a> =
        new Iterate(x, f) unsafely_as list<'a>,

    /// Removes duplicate elements from the list.
    /// The ordering of list is not preserved.
    nub is list?<'a> -> list<'a> =
        keys . hash,

    /// Returns a list of lists, where each sublist contains only equal elements
    /// and the concatenation of the result is equal to the original list l.
    /// Elements are considered equal when the given predicate function
    /// eq is true for them.
    groupBy eq l is ('a -> 'a -> boolean) -> list?<'a> -> list<list<'a>> =
        if empty? l then
            []
        else // this is an example of over-optimisation ;)
            var result = new MList();
            var collector = new MList();
            var i = l unsafely_as ~AIter;
            var prev = i#first();
            collector#add(prev);
            (i := i#next(); not nullptr? i) loop
               (val = i#first();
                if not ((val unsafely_as 'a) `eq` (prev unsafely_as 'a)) then
                    result#add(collector);
                    collector := new MList()
                fi;
                prev := val;
                collector#add(val));
            result#add(collector);
            result unsafely_as 'l
        fi,

    /// Sorts list. Same as sortBy (<)
    sort l is list?<^a> -> list<^a> =
        if empty? l then
            []
        else
            (l unsafely_as ~AList)#sort() unsafely_as list<^a>
        fi,

    /// Sorts list using given less? predicate function to determine the order.
    /// Merge sort algorithm is used.
    sortBy less? l is ('a -> 'a -> boolean) -> list?<'a> -> list<'a> =
        if empty? l then
            []
        else
            (l unsafely_as ~AList)#sort(less?) unsafely_as list<'a>
        fi,

    // few math functions
    pi = Math#PI,
    ln a = Math#log(a),
    exp a = Math#exp(a),
    cos a = Math#cos(a),
    sin a = Math#sin(a),
    tan a = Math#tan(a),
    acos a = Math#acos(a),
    asin a = Math#asin(a),
    atan a = Math#atan(a),
    sqrt a = Math#sqrt(a),
    int a is number -> number = (a as ~java.lang.Number)#longValue(),

    /// Replaces occurences of needle in the haystack with replacement
    strReplace needle replacement haystack
            is string -> string -> string -> string =
        Core#replace(needle unsafely_as ~String,
                     replacement unsafely_as ~String,
                     haystack unsafely_as ~String),

    /// String length
    norec strLength s = strLength s,

    /// String to upper case
    norec strUpper s = strUpper s,

    /// String to lower case
    norec strLower s = strLower s,

    /// Remove whitespace from start and end of the string
    norec strTrim s = strTrim s,

    /// Slice of the string
    norec strSlice s start end = strSlice s start end,

    /// Same as strSlice s pos (strLength s)
    norec strRight s pos = strRight s pos,

    /// Does the string s starts with string start?
    norec strStarts? s start = strStarts? s start,

    /// Does the string s ends with string end?
    norec strEnds? s end = strEnds? s end,

    /// Get an index of the needle substring in the haystack.
    /// Starts searching from index from
    norec strIndexOf haystack needle from = strIndexOf haystack needle from,

    /// Get an index of the needle substring in the haystack.
    /// Starts searching backwards from index from
    norec strLastIndexOf haystack needle from =
            strLastIndexOf haystack needle from,

    /// Same as strLastIndexOf haystack needle (strLength haystack)
    norec strLastIndexOf' haystack needle = strLastIndexOf haystack needle,

    norec strSplit re = strSplit re,
    norec substAll re = substAll re,
    norec matchAll re = matchAll re,
    norec like re = like re,
    norec strChar s pos = strChar s pos,

    strLeft s end = strSlice s 0 end,

    strLeftOf subString s is string -> string -> string =
        i = strIndexOf s subString 0;
        if i < 0 then undef_str else strSlice s 0 i fi,

    strRightOf subString s is string -> string -> string =
        i = strLastIndexOf' s subString;
        if i < 0 then undef_str else strRight s (i + strLength subString) fi,

    strJoin sep list is string -> list?<'a> -> string =
        if empty? list then
            ""
        else
            // use unsafely_as to not give null's for undef_str's
            buf = new java.lang.StringBuffer(
                        "\(head list)" unsafely_as ~String);
            var l = tail list;
            if sep == '' then
                not nullptr? l loop
                   (buf#append(head l as ~Object);
                    l := tail l)
            else
                not nullptr? l loop
                   (buf#append(sep unsafely_as ~String);
                    buf#append(head l as ~Object);
                    l := tail l)
            fi;
            buf#toString()
        fi,

    strPad pad n str is string -> number -> string -> string =
        if strLength str >= n then
            str
        else
            buf = new java.lang.StringBuffer(str unsafely_as ~String);
            buf#length() < n loop buf#append(pad unsafely_as ~String);
            buf#toString()
        fi,

    strCapitalize str is string -> string =
        Core#capitalize(str unsafely_as ~String),

    strUncapitalize str is string -> string =
        Core#uncapitalize(str unsafely_as ~String),

    mapHash f h is ('a -> 'b -> 'c) -> hash<'a, 'b> -> list?<'c> =
        a = new MList();
        a#reserve((h unsafely_as ~Map)#size());
        i = (h unsafely_as ~Map)#entrySet()#iterator();
        i#hasNext() loop
           (e = i#next() unsafely_as ~java.util.Map$Entry;
            a#add(f (e#getKey() unsafely_as 'a)
                    (e#getValue() unsafely_as 'b)));
        a unsafely_as list?<'c>,

    identityHash () is () -> hash<'a, 'b> =
        new IdentityHash() unsafely_as hash<'a, 'b>,

    copy h is 'a -> 'a =
        if nullptr? h then
            () as ~Object unsafely_as 'a
        else
            (h is map<'a, 'b> unsafely_as ~Coll)#copy() unsafely_as map<'a, 'b>
        fi,

    /**
     * Fail evaluation with given error message by throwing FailureException.
     *
     * Arguments:
     *  message - error message used as exception description
     *
     * Exceptions:
     *  FailureException - always.
     */
    failWith message =
        throw new FailureException(message),

    delete h k is map<'a, 'b> -> 'a -> () =
        _ = (h unsafely_as ~ByKey)#remove(k),

    deleteAll h ks is map<'a, 'b> -> list?<'a> -> () =
        _ = (h unsafely_as ~ByKey)#removeAll(ks),

    setHashDefault h f is hash<'a, 'b> -> ('a -> 'b) -> () =
        (h unsafely_as ~ByKey)#setDefault(f),

    clearHash h is hash<'a, 'b> -> () =
        (h unsafely_as ~Map)#clear(),

    insertHash h h' is hash<'a, 'b> -> hash<'a, 'b> -> () =
        _ = (h unsafely_as ~Map)#putAll(h' unsafely_as ~Map),

    setArrayCapacity a n is array<'a> -> number -> () =
        (a unsafely_as ~MList)#reserve(n),

    clearArray a is array<'a> -> () =
        (a unsafely_as ~MList)#clear(),

    shift a is array<'a> -> 'a =
        (a unsafely_as ~MList)#shift() unsafely_as 'a,

    pop a is array<'a> -> 'a =
        (a unsafely_as ~MList)#pop() unsafely_as 'a,

    push a v is array<'a> -> 'a -> () =
        (a unsafely_as ~MList)#add(v),

    slice a start end is array<'a> -> number -> number -> array<'a> =
        (a unsafely_as ~MList)#copy(start, end) unsafely_as array<'a>,

    collect f a endPred is ('a -> 'b) -> 'a -> ('b -> boolean) -> list<'b> =
       (l = new MList();
        (v = f a; not endPred v and (l#add(v); true)) loop;
        if l#isEmpty() then
            []
        else
            l unsafely_as list<'a>
        fi),

    filter f l is ('a -> boolean) -> list?<'a> -> list<'a> =
        if empty? l then
            []
        else
            FilterList#filter(l, f) unsafely_as list<'a>
        fi,

    catSome l is list?<Some 'a | None 'b> -> list<'a> =
        if empty? l then
            []
        else
            CatSomes#filter(l) unsafely_as list<'a>
        fi,

    map2 f a b is ('a -> 'b -> 'c) -> list?<'a> -> list?<'b> -> list<'c> =
        if empty? a or empty? b then
            []
        else
            new Map2List(f, a, b) unsafely_as list<'c>
        fi,

    revAppend a b is list?<'a> -> list<'a> -> list<'a> =
        if empty? a then
            b
        else
            var a = a unsafely_as ~AIter;
            var res = b;
            not nullptr? a loop
               (res := (a#first() unsafely_as 'a) :: res;
                a := a#next());
            res
        fi,

    reverse l is list?<'a> -> list<'a> =
        if nullptr? l then
            []
        else
            (l unsafely_as ~AList)#reverse() unsafely_as list<'a>
        fi,

    /// Provide return function for block.
    /// Be careful with lazy lists, for example
    /// withExit do e: 1 :. \(e []) done
    /// fails with exit out scope error..
    withExit f is (('a -> 'b) -> 'a) -> 'a =
        EscapeFun#with(f) unsafely_as 'a,

    threadLocal initialValue is 'a -> {var value is 'a} =
        class Local extends java.lang.ThreadLocal
            Object initialValue() initialValue
        end;
        tl = new Local();
        {
            get value () = tl#get() unsafely_as 'a,
            set value v  = tl#set(v)
        },

    stackTraceString ex is ~java.lang.Throwable -> string =
        sw = new java.io.StringWriter();
        ex#printStackTrace(new java.io.PrintWriter(sw));
        sw#toString(),

    /// The UTF-8 charset.
    utf8 = "UTF-8",

    /// Yeti version string. Don't try simple string comparision on it.
    /// At least convert it to number list with something like
    /// map number (strSplit '\D+' yetiRuntimeVersion) >= [0,9]
    yetiRuntimeVersion = "0.9.5+"
}
