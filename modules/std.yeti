/*
 * Yeti standard library.
 *
 * Copyright (c) 2008 Madis Janson
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
module yeti.lang.std;

import java.lang.Long;
import java.lang.Math;
import java.lang.IllegalArgumentException;

// like not . f, but a tiny bit faster
notPred f x = not (f x);

// struct inner bindings are non-polymorphic
array l is list?<'a> -> array<'a> =
    new MList(l) unsafely_as array<'a'>;

{
    id x = x;
    const x y = x;
    ignore x = ();
    at h k = h.[k];

    // functions for standard operators
    norec not v = not v;
    norec (and) a b = a and b;
    norec (or) a b = a or b;
    norec (in) a b = a in b;
    norec (==) a b = a == b;
    norec (!=) a b = a != b;
    norec (<)  a b = a <  b;
    norec (<=) a b = a <= b;
    norec (>)  a b = a >  b;
    norec (>=) a b = a >= b;
    norec (+)  a b = a + b;
    norec (-)  a b = a - b;
    norec (*)  a b = a * b;
    norec (/)  a b = a / b;
    norec (%)  a b = a % b;
    norec (.)  a b = a . b;
    norec (::) v l = v :: l;
    norec (:.) v l = v :. l;
    norec (=~) s p = s =~ p;
    norec (div) a b = a div b;
    norec (shl) a b = a shl b;
    norec (shr) a b = a shr b;
    norec negate a = negate a;
    norec raw_nullptr? a = raw_nullptr? a;
    norec synchronized monitor block = synchronized monitor block;
    (^) a b = "\(a)\(b)";

    norec array = array;

    flip f x y =
        f y x;
    number x =
        Core#parseNum(x is string);
    min a b =
        if a < b then a else b fi;
    max a b =
        if a > b then a else b fi;
    abs a =
        if a < 0 then -a else a fi;
    any f l =
        not (raw_nullptr? (find f l));
    all f l =
        raw_nullptr? (find (notPred f) l);
    contains v l =
        index v l != -1;
    fromSome default f opt =
        case opt of
        Some v: f v;
        None _: default;
        esac;

    // few math functions
    pi = Math#PI;
    exp a = Math#exp(a is number);
    cos a = Math#cos(a is number);
    sin a = Math#sin(a is number);
    tan a = Math#tan(a is number);
    acos a = Math#acos(a is number);
    asin a = Math#asin(a is number);
    atan a = Math#atan(a is number);
    sqrt a = Math#sqrt(a is number);

    replace needle replacement haystack
            is string -> string -> string -> string =
        Core#replace(needle, replacement, haystack);

    // TODO ineffective
    split re s is string -> string -> array<string> =
        new MList((s unsafely_as ~java.lang.String)#split(re))
            unsafely_as array<string>;

    forHash h f is hash<'a, 'b> -> ('a -> 'b -> ()) -> () =
       (i = (h unsafely_as ~Hash)#entrySet()#iterator();
        i#hasNext() loop
           (e = i#next() unsafely_as ~java.util.Map$Entry;
            f (e#getKey() unsafely_as 'a) (e#getValue() unsafely_as 'b)));

    mapHash f h is ('a -> 'b -> 'c) -> hash<'a, 'b> -> array<'c> =
       (a = array [];
        setArrayCapacity a (h unsafely_as ~Hash)#size();
        i = (h unsafely_as ~Hash)#entrySet()#iterator();
        i#hasNext() loop
           (e = i#next() unsafely_as ~java.util.Map$Entry;
            push a (f (e#getKey() unsafely_as 'a)
                      (e#getValue() unsafely_as 'b)));
        a);

    setHashDefault h f is hash<'a, 'b> -> ('a -> 'b) -> () =
        (h unsafely_as ~Hash)#defaultFun := (f unsafely_as ~Fun);

    head l is list?<'a> -> 'a =
       (if raw_nullptr? l then
            throw new IllegalArgumentException("Empty list")
        fi;
        (l unsafely_as ~AList)#first()) unsafely_as 'a;

    tail l is list?<'a> -> list<'a> =
       (if raw_nullptr? l then
            throw new IllegalArgumentException("Empty list")
        fi;
        (l unsafely_as ~AList)#rest()) unsafely_as list<'a>;

    index v l is 'a -> list?<'a> -> number =
        if raw_nullptr? l then
            -1
        else
            res = (l unsafely_as ~AList)#index(v);
            if raw_nullptr? res then -1 else res fi
        fi;

    setArrayCapacity a n is array<'a> -> number -> () =
        (a unsafely_as ~MList)#reserve(n);

    shift a is array<'a> -> 'a =
        (a unsafely_as ~MList)#shift() unsafely_as 'a;

    push a v is array<'a> -> 'a -> () =
        (a unsafely_as ~MList)#add(v);

    filter f l is ('a -> boolean) -> list?<'a> -> list<'a> =
        FilterList#filter(l, f) unsafely_as list<'a>;

    find f l is ('a -> boolean) -> list?<'a> -> list<'a> =
        if raw_nullptr? l then
            []
        else
            (l unsafely_as ~AList)#find(f) unsafely_as list<'a>
        fi;

    map f l is ('a -> 'b) -> list?<'a> -> list<'b> =
        if raw_nullptr? l then
            []
        else
            (l unsafely_as ~AList)#map(f) unsafely_as list<'b>
        fi;

    map2 f a b is ('a -> 'b -> 'c) -> list?<'a> -> list?<'b> -> list<'c> =
        if raw_nullptr? a or raw_nullptr? b then
            []
        else
            new Map2List(f, a, b) unsafely_as list<'c>
        fi;

    reverse l is list?<'a> -> list<'a> =
        if raw_nullptr? l then
            []
        else
            (l unsafely_as ~AList)#reverse() unsafely_as list<'a>
        fi;
}
